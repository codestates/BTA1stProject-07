/// <reference types="node" />
import { tx } from './tx';
import { msg } from './msg';
import { utils } from './utils';
import { crypto } from './crypto';
import { KavaClient } from './client';
export * from './types';
declare const Kava: {
    tx: {
        getTx: (path: string, base: string, timeout?: number, args?: {}) => Promise<any>;
        loadMetaData: (address: string, base: string, timeout?: number) => Promise<{
            account_number: string;
            sequence: string;
        }>;
        signTx: (tx: any, signMetaData: any, wallet: any) => any;
        broadcastTx: (tx: any, base: string, mode: string) => Promise<any>;
        logErr: (err: import("axios").AxiosError<any>) => void;
    };
    msg: {
        cosmos: {
            newStdTx: <T = unknown>(msgs: import("./types/Message").Message<T>[], fee?: {
                amount: never[];
                gas: string;
            }, memo?: string, signatures?: null) => {
                type: string;
                value: {
                    msg: import("./types/Message").Message<T>[];
                    fee: {
                        amount: never[];
                        gas: string;
                    };
                    signatures: null;
                    memo: string;
                };
            };
            newMsgSend: (address: string, to: string, coins: import("./types").Coin[]) => {
                type: string;
                value: {
                    from_address: string;
                    to_address: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgVoteGovernance: (proposalID: string, voter: string, voteType: import("./types").VoteType) => {
                type: string;
                value: {
                    voter: string;
                    proposal_id: string;
                    option: import("./types").VoteType;
                };
            };
            newMsgTransfer: (sourcePort: string, sourceChannel: string, token: import("./types").Coin, sender: string, receiver: string, timeoutTimestamp: number) => {
                type: string;
                value: {
                    source_port: string;
                    source_channel: string;
                    token: import("./types").Coin;
                    sender: string;
                    receiver: string;
                    timeout_height: {};
                    timeout_timestamp: string;
                };
            };
            newMsgDelegate: typeof import("./msg/cosmos").newMsgDelegate;
            newMsgUnDelegate: typeof import("./msg/cosmos").newMsgUnDelegate;
        };
        earn: {
            newMsgDeposit: (depositor: string, amount: import("./types").Coin, strategy: import("./types").Strategy) => {
                type: string;
                value: {
                    depositor: string;
                    amount: import("./types").Coin;
                    strategy: import("./types").Strategy;
                };
            };
            newMsgWithdraw: (from: string, amount: import("./types").Coin, strategy: import("./types").Strategy) => {
                type: string;
                value: {
                    from: string;
                    amount: import("./types").Coin;
                    strategy: import("./types").Strategy;
                };
            };
        };
        evmutil: {
            newMsgConvertERC20ToCoin: (initiator: string, receiver: string, kava_erc20_address: string, amount: string) => {
                type: string;
                value: {
                    initiator: string;
                    receiver: string;
                    kava_erc20_address: string;
                    amount: string;
                };
            };
            newMsgConvertCoinToERC20: (initiator: string, receiver: string, amount: import("./types").Coin) => {
                type: string;
                value: {
                    initiator: string;
                    receiver: string;
                    amount: import("./types").Coin;
                };
            };
        };
        hard: {
            newMsgDeposit: (depositor: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    depositor: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgWithdraw: (depositor: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    depositor: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgBorrow: (borrower: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    borrower: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgRepay: (sender: string, owner: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    sender: string;
                    owner: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgLiquidate: (keeper: string, borrower: string) => {
                type: string;
                value: {
                    keeper: string;
                    borrower: string;
                };
            };
        };
        kava: {
            newMsgPlaceBid: (auctionID: string, bidder: string, amount: import("./types").Coin) => {
                type: string;
                value: {
                    auction_id: string;
                    bidder: string;
                    amount: import("./types").Coin;
                };
            };
            newMsgCreateAtomicSwap: (from: string, to: string, recipientOtherChain: string, senderOtherChain: string, randomNumberHash: string, timestamp: number, amount: import("./types").Coin[], heightSpan: number) => {
                type: string;
                value: {
                    from: string;
                    to: string;
                    recipient_other_chain: string;
                    sender_other_chain: string;
                    random_number_hash: string;
                    timestamp: string;
                    amount: import("./types").Coin[];
                    height_span: string;
                };
            };
            newMsgClaimAtomicSwap: (from: string, swapID: string, randomNumber: string) => {
                type: string;
                value: {
                    from: string;
                    swap_id: string;
                    random_number: string;
                };
            };
            newMsgRefundAtomicSwap: (from: string, swapID: string) => {
                type: string;
                value: {
                    from: string;
                    swap_id: string;
                };
            };
            newMsgCreateCDP: (sender: string, principal: import("./types").Coin, collateral: import("./types").Coin, collateralType: string) => {
                type: string;
                value: {
                    sender: string;
                    principal: import("./types").Coin;
                    collateral: import("./types").Coin;
                    collateral_type: string;
                };
            };
            newMsgDeposit: (owner: string, depositor: string, collateral: import("./types").Coin, collateralType: string) => {
                type: string;
                value: {
                    owner: string;
                    depositor: string;
                    collateral: import("./types").Coin;
                    collateral_type: string;
                };
            };
            newMsgWithdraw: (owner: string, depositor: string, collateral: import("./types").Coin, collateralType: string) => {
                type: string;
                value: {
                    owner: string;
                    depositor: string;
                    collateral: import("./types").Coin;
                    collateral_type: string;
                };
            };
            newMsgDrawDebt: (sender: string, collateralType: string, principal: import("./types").Coin) => {
                type: string;
                value: {
                    sender: string;
                    collateral_type: string;
                    principal: import("./types").Coin;
                };
            };
            newMsgRepayDebt: (sender: string, collateralType: string, payment: import("./types").Coin) => {
                type: string;
                value: {
                    sender: string;
                    collateral_type: string;
                    payment: import("./types").Coin;
                };
            };
            newMsgLiquidate: (keeper: string, borrower: string, collateralType: string) => {
                type: string;
                value: {
                    keeper: string;
                    borrower: string;
                    collateral_type: string;
                };
            };
            newMsgSubmitProposal: (pubProposal: string, proposer: string, committeeID: string) => {
                type: string;
                value: {
                    pub_proposal: string;
                    proposer: string;
                    committee_id: string;
                };
            };
            newMsgVote: (proposalID: string, voter: string, voteType: import("./types").VoteType) => {
                type: string;
                value: {
                    proposal_id: string;
                    voter: string;
                    vote_type: import("./types").VoteType;
                };
            };
            newMsgClaimUSDXMintingReward: (sender: string, multiplierName: string) => {
                type: string;
                value: {
                    sender: string;
                    multiplier_name: string;
                };
            };
            newMsgClaimHardReward: (sender: string, denomsToClaim: import("./types").DenomToClaim[]) => {
                type: string;
                value: {
                    sender: string;
                    denoms_to_claim: import("./types").DenomToClaim[];
                };
            };
            newMsgClaimDelegatorReward: (sender: string, denomsToClaim: import("./types").DenomToClaim[]) => {
                type: string;
                value: {
                    sender: string;
                    denoms_to_claim: import("./types").DenomToClaim[];
                };
            };
            newMsgClaimSwapReward: (sender: string, denomsToClaim: import("./types").DenomToClaim[]) => {
                type: string;
                value: {
                    sender: string;
                    denoms_to_claim: import("./types").DenomToClaim[];
                };
            };
            newMsgClaimSavingsReward: (sender: string, denomsToClaim: import("./types").DenomToClaim[]) => {
                type: string;
                value: {
                    sender: string;
                    denoms_to_claim: import("./types").DenomToClaim[];
                };
            };
            newMsgClaimEarnReward: (sender: string, denomsToClaim: import("./types").DenomToClaim[]) => {
                type: string;
                value: {
                    sender: string;
                    denoms_to_claim: import("./types").DenomToClaim[];
                };
            };
            newMsgIssueTokens: (sender: string, tokens: import("./types").Coin[], receiver: string) => {
                type: string;
                value: {
                    sender: string;
                    tokens: import("./types").Coin[];
                    receiver: string;
                };
            };
            newMsgRedeemTokens: (sender: string, tokens: import("./types").Coin[]) => {
                type: string;
                value: {
                    sender: string;
                    tokens: import("./types").Coin[];
                };
            };
            newMsgBlockAddress: (sender: string, denom: string, blockedAddress: string) => {
                type: string;
                value: {
                    sender: string;
                    denom: string;
                    blocked_address: string;
                };
            };
            newMsgUnblockAddress: (sender: string, denom: string, address: string) => {
                type: string;
                value: {
                    sender: string;
                    denom: string;
                    address: string;
                };
            };
            newMsgSetPauseStatus: (sender: string, denom: string, status: string) => {
                type: string;
                value: {
                    sender: string;
                    denom: string;
                    status: string;
                };
            };
            newMsgPostPrice: (from: string, marketID: string, price: string, expiry: string) => {
                type: string;
                value: {
                    from: string;
                    market_id: string;
                    price: string;
                    expiry: string;
                };
            };
        };
        liquid: {
            newMsgMintDerivative: (sender: string, validator: string, amount: import("./types").Coin) => {
                type: string;
                value: {
                    sender: string;
                    validator: string;
                    amount: import("./types").Coin;
                };
            };
            newMsgBurnDerivative: (sender: string, validator: string, amount: import("./types").Coin) => {
                type: string;
                value: {
                    sender: string;
                    validator: string;
                    amount: import("./types").Coin;
                };
            };
        };
        router: {
            newMsgMintDeposit: (depositor: string, validator: string, amount?: import("./types").Coin | undefined) => {
                type: string;
                value: {
                    depositor: string;
                    validator: string;
                    amount: import("./types").Coin | undefined;
                };
            };
            newMsgDelegateMintDeposit: (depositor: string, validator: string, amount?: import("./types").Coin | undefined) => {
                type: string;
                value: {
                    depositor: string;
                    validator: string;
                    amount: import("./types").Coin | undefined;
                };
            };
            newMsgWithdrawBurn: (from: string, validator: string, amount?: import("./types").Coin | undefined) => {
                type: string;
                value: {
                    from: string;
                    validator: string;
                    amount: import("./types").Coin | undefined;
                };
            };
            newMsgWithdrawBurnUndelegate: (from: string, validator: string, amount?: import("./types").Coin | undefined) => {
                type: string;
                value: {
                    from: string;
                    validator: string;
                    amount: import("./types").Coin | undefined;
                };
            };
        };
        savings: {
            newMsgDeposit: (depositor: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    depositor: string;
                    amount: import("./types").Coin[];
                };
            };
            newMsgWithdraw: (depositor: string, amount: import("./types").Coin[]) => {
                type: string;
                value: {
                    depositor: string;
                    amount: import("./types").Coin[];
                };
            };
        };
        swap: {
            newMsgDeposit: (depositor: string, tokenA: import("./types").Coin, tokenB: import("./types").Coin, slippage: string, deadline: string) => {
                type: string;
                value: {
                    depositor: string;
                    token_a: import("./types").Coin;
                    token_b: import("./types").Coin;
                    slippage: string;
                    deadline: string;
                };
            };
            newMsgWithdraw: (from: string, shares: any, minTokenA: import("./types").Coin, minTokenB: import("./types").Coin, deadline: string) => {
                type: string;
                value: {
                    from: string;
                    shares: any;
                    min_token_a: import("./types").Coin;
                    min_token_b: import("./types").Coin;
                    deadline: string;
                };
            };
            newMsgSwapExactForTokens: (requester: string, exactTokenA: import("./types").Coin, tokenB: import("./types").Coin, slippage: string, deadline: string) => {
                type: string;
                value: {
                    requester: string;
                    exact_token_a: import("./types").Coin;
                    token_b: import("./types").Coin;
                    slippage: string;
                    deadline: string;
                };
            };
            newMsgSwapForExactTokens: (requester: string, tokenA: import("./types").Coin, exactTokenB: import("./types").Coin, slippage: string, deadline: string) => {
                type: string;
                value: {
                    requester: string;
                    token_a: import("./types").Coin;
                    exact_token_b: import("./types").Coin;
                    slippage: string;
                    deadline: string;
                };
            };
        };
    };
    utils: {
        generateRandomNumber: () => string;
        calculateRandomNumberHash: (randomNumber: string, timestamp: number) => string;
        calculateSwapID: (randomNumberHash: string, sender: string, senderOtherChain: string) => string;
        calculateUnixTime: (seconds?: number) => string;
        convertCoinDecimals: (inputAmount: string, inputDenom: string, outputDenom: string) => {
            denom: string;
            amount: string;
        }[] | undefined;
        formatCoin: (amount: string | number, denom: string) => {
            denom: string;
            amount: string;
        };
        formatCoins: (amount: string | number, denom: string) => {
            denom: string;
            amount: string;
        }[];
        formatMultiCoins: (amounts: string[], denoms: string[]) => {
            denom: string;
            amount: string;
        }[] | undefined;
        ethToKavaAddress: typeof import("./utils").ethToKavaAddress;
        kavaToEthAddress: typeof import("./utils").kavaToEthAddress;
    };
    crypto: {
        generateMnemonic: () => string;
        getAddressFromMnemonic: (mnemonic: string, legacy?: boolean) => any;
        decodeAddress: (value: string) => Buffer;
        checkAddress: (address: string, hrp: string) => boolean;
    };
    KavaClient: typeof KavaClient;
};
export { tx, msg, utils, crypto, KavaClient };
export default Kava;
