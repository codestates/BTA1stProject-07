export declare const msg: {
    cosmos: {
        newStdTx: <T = unknown>(msgs: import("../types/Message").Message<T>[], fee?: {
            amount: never[];
            gas: string;
        }, memo?: string, signatures?: null) => {
            type: string;
            value: {
                msg: import("../types/Message").Message<T>[];
                fee: {
                    amount: never[];
                    gas: string;
                };
                signatures: null;
                memo: string;
            };
        };
        newMsgSend: (address: string, to: string, coins: import("..").Coin[]) => {
            type: string;
            value: {
                from_address: string;
                to_address: string;
                amount: import("..").Coin[];
            };
        };
        newMsgVoteGovernance: (proposalID: string, voter: string, voteType: import("..").VoteType) => {
            type: string;
            value: {
                voter: string;
                proposal_id: string;
                option: import("..").VoteType;
            };
        };
        newMsgTransfer: (sourcePort: string, sourceChannel: string, token: import("..").Coin, sender: string, receiver: string, timeoutTimestamp: number) => {
            type: string;
            value: {
                source_port: string;
                source_channel: string;
                token: import("..").Coin;
                sender: string;
                receiver: string;
                timeout_height: {};
                timeout_timestamp: string;
            };
        };
        newMsgDelegate: typeof import("./cosmos").newMsgDelegate;
        newMsgUnDelegate: typeof import("./cosmos").newMsgUnDelegate;
    };
    earn: {
        newMsgDeposit: (depositor: string, amount: import("..").Coin, strategy: import("..").Strategy) => {
            type: string;
            value: {
                depositor: string;
                amount: import("..").Coin;
                strategy: import("..").Strategy;
            };
        };
        newMsgWithdraw: (from: string, amount: import("..").Coin, strategy: import("..").Strategy) => {
            type: string;
            value: {
                from: string;
                amount: import("..").Coin;
                strategy: import("..").Strategy;
            };
        };
    };
    evmutil: {
        newMsgConvertERC20ToCoin: (initiator: string, receiver: string, kava_erc20_address: string, amount: string) => {
            type: string;
            value: {
                initiator: string;
                receiver: string;
                kava_erc20_address: string;
                amount: string;
            };
        };
        newMsgConvertCoinToERC20: (initiator: string, receiver: string, amount: import("..").Coin) => {
            type: string;
            value: {
                initiator: string;
                receiver: string;
                amount: import("..").Coin;
            };
        };
    };
    hard: {
        newMsgDeposit: (depositor: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                depositor: string;
                amount: import("..").Coin[];
            };
        };
        newMsgWithdraw: (depositor: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                depositor: string;
                amount: import("..").Coin[];
            };
        };
        newMsgBorrow: (borrower: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                borrower: string;
                amount: import("..").Coin[];
            };
        };
        newMsgRepay: (sender: string, owner: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                sender: string;
                owner: string;
                amount: import("..").Coin[];
            };
        };
        newMsgLiquidate: (keeper: string, borrower: string) => {
            type: string;
            value: {
                keeper: string;
                borrower: string;
            };
        };
    };
    kava: {
        newMsgPlaceBid: (auctionID: string, bidder: string, amount: import("..").Coin) => {
            type: string;
            value: {
                auction_id: string;
                bidder: string;
                amount: import("..").Coin;
            };
        };
        newMsgCreateAtomicSwap: (from: string, to: string, recipientOtherChain: string, senderOtherChain: string, randomNumberHash: string, timestamp: number, amount: import("..").Coin[], heightSpan: number) => {
            type: string;
            value: {
                from: string;
                to: string;
                recipient_other_chain: string;
                sender_other_chain: string;
                random_number_hash: string;
                timestamp: string;
                amount: import("..").Coin[];
                height_span: string;
            };
        };
        newMsgClaimAtomicSwap: (from: string, swapID: string, randomNumber: string) => {
            type: string;
            value: {
                from: string;
                swap_id: string;
                random_number: string;
            };
        };
        newMsgRefundAtomicSwap: (from: string, swapID: string) => {
            type: string;
            value: {
                from: string;
                swap_id: string;
            };
        };
        newMsgCreateCDP: (sender: string, principal: import("..").Coin, collateral: import("..").Coin, collateralType: string) => {
            type: string;
            value: {
                sender: string;
                principal: import("..").Coin;
                collateral: import("..").Coin;
                collateral_type: string;
            };
        };
        newMsgDeposit: (owner: string, depositor: string, collateral: import("..").Coin, collateralType: string) => {
            type: string;
            value: {
                owner: string;
                depositor: string;
                collateral: import("..").Coin;
                collateral_type: string;
            };
        };
        newMsgWithdraw: (owner: string, depositor: string, collateral: import("..").Coin, collateralType: string) => {
            type: string;
            value: {
                owner: string;
                depositor: string;
                collateral: import("..").Coin;
                collateral_type: string;
            };
        };
        newMsgDrawDebt: (sender: string, collateralType: string, principal: import("..").Coin) => {
            type: string;
            value: {
                sender: string;
                collateral_type: string;
                principal: import("..").Coin;
            };
        };
        newMsgRepayDebt: (sender: string, collateralType: string, payment: import("..").Coin) => {
            type: string;
            value: {
                sender: string;
                collateral_type: string;
                payment: import("..").Coin;
            };
        };
        newMsgLiquidate: (keeper: string, borrower: string, collateralType: string) => {
            type: string;
            value: {
                keeper: string;
                borrower: string;
                collateral_type: string;
            };
        };
        newMsgSubmitProposal: (pubProposal: string, proposer: string, committeeID: string) => {
            type: string;
            value: {
                pub_proposal: string;
                proposer: string;
                committee_id: string;
            };
        };
        newMsgVote: (proposalID: string, voter: string, voteType: import("..").VoteType) => {
            type: string;
            value: {
                proposal_id: string;
                voter: string;
                vote_type: import("..").VoteType;
            };
        };
        newMsgClaimUSDXMintingReward: (sender: string, multiplierName: string) => {
            type: string;
            value: {
                sender: string;
                multiplier_name: string;
            };
        };
        newMsgClaimHardReward: (sender: string, denomsToClaim: import("..").DenomToClaim[]) => {
            type: string;
            value: {
                sender: string;
                denoms_to_claim: import("..").DenomToClaim[];
            };
        };
        newMsgClaimDelegatorReward: (sender: string, denomsToClaim: import("..").DenomToClaim[]) => {
            type: string;
            value: {
                sender: string;
                denoms_to_claim: import("..").DenomToClaim[];
            };
        };
        newMsgClaimSwapReward: (sender: string, denomsToClaim: import("..").DenomToClaim[]) => {
            type: string;
            value: {
                sender: string;
                denoms_to_claim: import("..").DenomToClaim[];
            };
        };
        newMsgClaimSavingsReward: (sender: string, denomsToClaim: import("..").DenomToClaim[]) => {
            type: string;
            value: {
                sender: string;
                denoms_to_claim: import("..").DenomToClaim[];
            };
        };
        newMsgClaimEarnReward: (sender: string, denomsToClaim: import("..").DenomToClaim[]) => {
            type: string;
            value: {
                sender: string;
                denoms_to_claim: import("..").DenomToClaim[];
            };
        };
        newMsgIssueTokens: (sender: string, tokens: import("..").Coin[], receiver: string) => {
            type: string;
            value: {
                sender: string;
                tokens: import("..").Coin[];
                receiver: string;
            };
        };
        newMsgRedeemTokens: (sender: string, tokens: import("..").Coin[]) => {
            type: string;
            value: {
                sender: string;
                tokens: import("..").Coin[];
            };
        };
        newMsgBlockAddress: (sender: string, denom: string, blockedAddress: string) => {
            type: string;
            value: {
                sender: string;
                denom: string;
                blocked_address: string;
            };
        };
        newMsgUnblockAddress: (sender: string, denom: string, address: string) => {
            type: string;
            value: {
                sender: string;
                denom: string;
                address: string;
            };
        };
        newMsgSetPauseStatus: (sender: string, denom: string, status: string) => {
            type: string;
            value: {
                sender: string;
                denom: string;
                status: string;
            };
        };
        newMsgPostPrice: (from: string, marketID: string, price: string, expiry: string) => {
            type: string;
            value: {
                from: string;
                market_id: string;
                price: string;
                expiry: string;
            };
        };
    };
    liquid: {
        newMsgMintDerivative: (sender: string, validator: string, amount: import("..").Coin) => {
            type: string;
            value: {
                sender: string;
                validator: string;
                amount: import("..").Coin;
            };
        };
        newMsgBurnDerivative: (sender: string, validator: string, amount: import("..").Coin) => {
            type: string;
            value: {
                sender: string;
                validator: string;
                amount: import("..").Coin;
            };
        };
    };
    router: {
        newMsgMintDeposit: (depositor: string, validator: string, amount?: import("..").Coin | undefined) => {
            type: string;
            value: {
                depositor: string;
                validator: string;
                amount: import("..").Coin | undefined;
            };
        };
        newMsgDelegateMintDeposit: (depositor: string, validator: string, amount?: import("..").Coin | undefined) => {
            type: string;
            value: {
                depositor: string;
                validator: string;
                amount: import("..").Coin | undefined;
            };
        };
        newMsgWithdrawBurn: (from: string, validator: string, amount?: import("..").Coin | undefined) => {
            type: string;
            value: {
                from: string;
                validator: string;
                amount: import("..").Coin | undefined;
            };
        };
        newMsgWithdrawBurnUndelegate: (from: string, validator: string, amount?: import("..").Coin | undefined) => {
            type: string;
            value: {
                from: string;
                validator: string;
                amount: import("..").Coin | undefined;
            };
        };
    };
    savings: {
        newMsgDeposit: (depositor: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                depositor: string;
                amount: import("..").Coin[];
            };
        };
        newMsgWithdraw: (depositor: string, amount: import("..").Coin[]) => {
            type: string;
            value: {
                depositor: string;
                amount: import("..").Coin[];
            };
        };
    };
    swap: {
        newMsgDeposit: (depositor: string, tokenA: import("..").Coin, tokenB: import("..").Coin, slippage: string, deadline: string) => {
            type: string;
            value: {
                depositor: string;
                token_a: import("..").Coin;
                token_b: import("..").Coin;
                slippage: string;
                deadline: string;
            };
        };
        newMsgWithdraw: (from: string, shares: any, minTokenA: import("..").Coin, minTokenB: import("..").Coin, deadline: string) => {
            type: string;
            value: {
                from: string;
                shares: any;
                min_token_a: import("..").Coin;
                min_token_b: import("..").Coin;
                deadline: string;
            };
        };
        newMsgSwapExactForTokens: (requester: string, exactTokenA: import("..").Coin, tokenB: import("..").Coin, slippage: string, deadline: string) => {
            type: string;
            value: {
                requester: string;
                exact_token_a: import("..").Coin;
                token_b: import("..").Coin;
                slippage: string;
                deadline: string;
            };
        };
        newMsgSwapForExactTokens: (requester: string, tokenA: import("..").Coin, exactTokenB: import("..").Coin, slippage: string, deadline: string) => {
            type: string;
            value: {
                requester: string;
                token_a: import("..").Coin;
                exact_token_b: import("..").Coin;
                slippage: string;
                deadline: string;
            };
        };
    };
};
