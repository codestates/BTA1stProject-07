import { Coin } from '../../types/Coin';
import { Message } from '../../types/Message';
import { VoteType } from '../../types/VoteType';
/**
 * Creates a new StdTx from some messages with a default fee
 * @param {Object} msgs an array of msgs to be included in the transaction
 * @param {Object} fee optional fee
 * @param {Object} memo optional memo
 * @param {Object} signatures generated when an address signs a data package, required for tx confirmation
 * @return {Promise}
 */
declare function newStdTx<T = unknown>(msgs: Message<T>[], fee?: {
    amount: never[];
    gas: string;
}, memo?: string, signatures?: null): {
    type: string;
    value: {
        msg: Message<T>[];
        fee: {
            amount: never[];
            gas: string;
        };
        signatures: null;
        memo: string;
    };
};
declare function newMsgSend(address: string, to: string, coins: Coin[]): {
    type: string;
    value: {
        from_address: string;
        to_address: string;
        amount: Coin[];
    };
};
declare function newMsgVoteGovernance(proposalID: string, voter: string, voteType: VoteType): {
    type: string;
    value: {
        voter: string;
        proposal_id: string;
        option: VoteType;
    };
};
/**
 * Creates an IBC transfer
 * @param {String} sourcePort the port identifier, we would expect to always be "transfer" * @param {String} sourcePort the port identifier, we would expect to always be "transfer"
 * @param {String} source_channel the channel identifier
 * @param {Coin} token
 * @param {String} sender address of sender on the origin chain
 * @param {String} receiver address of recipient on the destination chain
 * @param {Integer} timeoutTimestamp nanoseconds to allow transfer to complete

 */
declare function newMsgTransfer(sourcePort: string, sourceChannel: string, token: Coin, sender: string, receiver: string, timeoutTimestamp: number): {
    type: string;
    value: {
        source_port: string;
        source_channel: string;
        token: Coin;
        sender: string;
        receiver: string;
        timeout_height: {};
        timeout_timestamp: string;
    };
};
export declare function newMsgDelegate(delegatorAddress: string, validatorAddress: string, amount: Coin): {
    type: string;
    value: {
        delegator_address: string;
        validator_address: string;
        amount: Coin;
    };
};
export declare function newMsgUnDelegate(delegatorAddress: string, validatorAddress: string, amount: Coin): {
    type: string;
    value: {
        delegator_address: string;
        validator_address: string;
        amount: Coin;
    };
};
export declare const cosmos: {
    newStdTx: typeof newStdTx;
    newMsgSend: typeof newMsgSend;
    newMsgVoteGovernance: typeof newMsgVoteGovernance;
    newMsgTransfer: typeof newMsgTransfer;
    newMsgDelegate: typeof newMsgDelegate;
    newMsgUnDelegate: typeof newMsgUnDelegate;
};
export {};
