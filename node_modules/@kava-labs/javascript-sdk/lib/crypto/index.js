"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
var sig = require('@kava-labs/sig');
var bech32_1 = __importDefault(require("bech32"));
var bip39_1 = __importDefault(require("bip39"));
var KAVA_PREFIX = 'kava';
var MNEMONIC_LEN = 256;
var DECODED_ADDRESS_LEN = 20;
var DERIVATION_PATH = "m/44'/459'/0'/0/0";
var DERIVATION_PATH_LEGACY = "m/44'/118'/0'/0/0";
/**
 * Generates mnemonic phrase words using random entropy.
 */
var generateMnemonic = function () { return bip39_1.default.generateMnemonic(MNEMONIC_LEN); };
/**
 * Loads a key pair from a mnemonic phrase.
 * @param {string} mnemonic the mnemonic from which to generate the key pair
 * @param {boolean} legacy optional boolean to use the legacy coin type
 */
var getAddressFromMnemonic = function (mnemonic, legacy) {
    if (legacy === void 0) { legacy = false; }
    var derivationPath = legacy ? DERIVATION_PATH_LEGACY : DERIVATION_PATH;
    var masterKey = sig.createMasterKeyFromMnemonic(mnemonic);
    var keyPair = sig.createKeyPairFromMasterKey(masterKey, derivationPath);
    return sig.createAddress(keyPair.publicKey, KAVA_PREFIX);
};
/**
 * Decodes an address in bech32 format.
 * @param {string} value the bech32 address to decode
 */
var decodeAddress = function (value) {
    var decodeAddress = bech32_1.default.decode(value);
    return Buffer.from(bech32_1.default.fromWords(decodeAddress.words));
};
/**
 * Checks whether an address is valid.
 * @param {string} address the bech32 address to decode
 * @param {string} hrp the prefix to check for the bech32 address
 * @return {boolean}
 */
var checkAddress = function (address, hrp) {
    try {
        if (!address.startsWith(hrp)) {
            return false;
        }
        var decodedAddress = bech32_1.default.decode(address);
        var decodedAddressLength = decodeAddress(address).length;
        if (decodedAddressLength === DECODED_ADDRESS_LEN &&
            decodedAddress.prefix === hrp) {
            return true;
        }
        return false;
    }
    catch (err) {
        return false;
    }
};
exports.crypto = {
    generateMnemonic: generateMnemonic,
    getAddressFromMnemonic: getAddressFromMnemonic,
    decodeAddress: decodeAddress,
    checkAddress: checkAddress,
};
