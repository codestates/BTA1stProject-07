"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.ethToKavaAddress = exports.kavaToEthAddress = void 0;
var sha256_1 = __importDefault(require("crypto-js/sha256"));
var enc_hex_1 = __importDefault(require("crypto-js/enc-hex"));
var big_js_1 = __importDefault(require("big.js"));
var crypto_1 = __importDefault(require("crypto"));
var crypto_2 = require("../crypto");
var ethers_1 = require("ethers");
var bech32_1 = __importDefault(require("bech32"));
var RandomNumberLength = 64;
// Precision is relative to KAVA or 10**6
var precision = {
    kava: 1,
    ukava: Math.pow(10, 6),
};
/**
 * Computes a single SHA256 digest.
 * @param {string} hex message to hash
 * @returns {string} hash output
 */
var sha256 = function (hex) {
    if (typeof hex !== 'string')
        throw new Error('sha256 expects a hex string');
    if (hex.length % 2 !== 0)
        throw new Error("invalid hex string length: " + hex);
    var hexEncoded = enc_hex_1.default.parse(hex);
    return (0, sha256_1.default)(hexEncoded).toString();
};
/**
 * Generates a hex-encoded 256-bit random number
 * @returns {string} the hex-encoded number
 */
var generateRandomNumber = function () {
    return crypto_1.default
        .randomBytes(Math.ceil(RandomNumberLength / 2))
        .toString('hex')
        .slice(0, RandomNumberLength);
};
/**
 * Computes sha256 of random number and timestamp
 * @param {String} randomNumber
 * @param {Number} timestamp
 * @returns {string} sha256 result
 */
var calculateRandomNumberHash = function (randomNumber, timestamp) {
    var timestampHexStr = timestamp.toString(16);
    var timestampHexStrFormat = timestampHexStr;
    for (var i = 0; i < 16 - timestampHexStr.length; i++) {
        timestampHexStrFormat = '0' + timestampHexStrFormat;
    }
    var timestampBytes = Buffer.from(timestampHexStrFormat, 'hex');
    var newBuffer = Buffer.concat([
        Buffer.from(randomNumber, 'hex'),
        timestampBytes,
    ]);
    return sha256(newBuffer.toString('hex'));
};
/**
 * Computes swapID
 * @param {String} randomNumberHash
 * @param {String} sender
 * @param {String} senderOtherChain
 * @returns {string} sha256 result
 */
var calculateSwapID = function (randomNumberHash, sender, senderOtherChain) {
    var randomNumberHashBytes = Buffer.from(randomNumberHash, 'hex');
    var senderBytes = crypto_2.crypto.decodeAddress(sender);
    var sendOtherChainBytes = Buffer.from(senderOtherChain.toLowerCase(), 'utf8');
    var newBuffer = Buffer.concat([
        randomNumberHashBytes,
        senderBytes,
        sendOtherChainBytes,
    ]);
    return sha256(newBuffer.toString('hex'));
};
/**
 * Converts coin decimals between kava and ukava
 * @param {String} inputAmount value of the input asset
 * @param {String} inputDenom denom of the input asset
 * @param {String} outputDenom denom of the output asset
 * @return {object} coins result
 */
var convertCoinDecimals = function (inputAmount, inputDenom, outputDenom) {
    var amount = new big_js_1.default(inputAmount);
    try {
        if (!precision[inputDenom] || !precision[outputDenom]) {
            throw new Error('Invalid asset pairing for decimal conversion.');
        }
    }
    catch (err) {
        if (err instanceof Error) {
            console.log('Error:', err.message);
        }
        return;
    }
    var amountString = amount
        .mul(precision[outputDenom])
        .div(precision[inputDenom])
        .toString();
    return formatCoins(amountString, outputDenom);
};
/**
 * Formats a denom and amount into Cosmos-SDK compatible sdk.Coin object
 * @param {String} amount value of the asset
 * @param {String} denom name of the asset
 * @return {object} resulting formatted coin
 */
var formatCoin = function (amount, denom) {
    return {
        denom: String(denom),
        amount: String(amount),
    };
};
/**
 * Formats a denom and amount into Cosmos-SDK compatible sdk.Coins object
 * @param {String} amount value of the asset
 * @param {String} denom name of the asset
 * @return {object} resulting formatted coins
 */
var formatCoins = function (amount, denom) {
    return [
        {
            denom: String(denom),
            amount: String(amount),
        },
    ];
};
/**
 * Formats an array of denoms and amounts into Cosmos-SDK compatible sdk.Coins object
 * @param {String} amounts an array of asset amounts
 * @param {String} denoms an array of asset denoms
 * @return {object} resulting formatted coins
 */
var formatMultiCoins = function (amounts, denoms) {
    try {
        if (amounts.length != denoms.length) {
            throw new Error('Every amount must have exactly 1 corresponding denom.');
        }
    }
    catch (err) {
        if (err instanceof Error) {
            console.log('Error:', err.message);
        }
        return;
    }
    var coins = [];
    for (var i = 0; i < amounts.length; i++) {
        var coin = formatCoin(amounts[i], denoms[i]);
        coins.push(coin);
    }
    return coins;
};
/**
 * Takes current day and adds desired amount of seconds and converts to unix time
 * @param {number} seconds for the transaction to process
 * @return {object} resulting in a unix timestring, defaulting to 1 day
 */
var calculateUnixTime = function (seconds) {
    if (seconds === void 0) { seconds = 86400; }
    return String(Math.floor(Date.now() / 1000) + seconds);
};
/**
 *
 * @param kavaAddress string
 * @returns string representing eth address from given kava address
 */
function kavaToEthAddress(kavaAddress) {
    return ethers_1.ethers.utils.getAddress(ethers_1.ethers.utils.hexlify(bech32_1.default.fromWords(bech32_1.default.decode(kavaAddress).words)));
}
exports.kavaToEthAddress = kavaToEthAddress;
/**
 *
 * @param ethereumAddress string
 * @returns string representing kava address from give eth address
 */
function ethToKavaAddress(ethereumAddress) {
    return bech32_1.default.encode('kava', bech32_1.default.toWords(ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.getAddress(ethereumAddress))));
}
exports.ethToKavaAddress = ethToKavaAddress;
exports.utils = {
    generateRandomNumber: generateRandomNumber,
    calculateRandomNumberHash: calculateRandomNumberHash,
    calculateSwapID: calculateSwapID,
    calculateUnixTime: calculateUnixTime,
    convertCoinDecimals: convertCoinDecimals,
    formatCoin: formatCoin,
    formatCoins: formatCoins,
    formatMultiCoins: formatMultiCoins,
    ethToKavaAddress: ethToKavaAddress,
    kavaToEthAddress: kavaToEthAddress,
};
