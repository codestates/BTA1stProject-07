import { Hard } from './hard';
import { Swap } from './swap';
import { DenomToClaim } from '../types/DenomToClaim';
import { VoteType } from '../types/VoteType';
import { Wallet } from '../types/Wallet';
import { Coin } from '../types/Coin';
/**
 * The Kava client.
 */
export declare class KavaClient {
    baseURI: string;
    broadcastMode: string;
    hard: Hard;
    swap: Swap;
    wallet?: Wallet;
    chainID?: string;
    accNum?: string;
    /**
     * @param {String} server Kava public url
     */
    constructor(server: string);
    /**
     * Initialize the client with the chain's ID. Asynchronous.
     * @return {Promise}
     */
    initChain(): Promise<this>;
    /**
     * Manually set the chain's ID
     * @param {String} chainID Kava chain ID
     */
    setChainID(chainID: string): this;
    /**
     * Manually set the wallet's account number
     * @param {String} accNum Account number of the Kava address
     */
    setAccountNumber(accNum: string): this;
    /**
     * Set broadcast mode
     * @param {String} mode transaction broadcast mode
     */
    setBroadcastMode(mode: string): this;
    /**
     * Set the client's wallet which is used for signature generation
     * @param {String} mnemonic Kava address mnemonic
     * @param {String} password optional param for wallet password
     * @param {boolean} legacy optional param to use the legacy coin type
     * @return {Promise}
     */
    setWallet(mnemonic: string, password?: string, legacy?: boolean): this;
    /**
     * Load account number, sequence, and package with chain ID for signature
     * @param {String} sequence Kava address sequence
     * @return {Promise}
     */
    prepareSignInfo(sequence: string | null): Promise<{
        chain_id: string | undefined;
        account_number: string;
        sequence: string;
    }>;
    /**
     * Sends messages to the Kava blockchain
     * @param {Array} msgs an array of msgs to be sent
     * @param {Object} fee the transaction's fee that includes gas amount
     * @param {String} sequence account sequence
     * @return {Promise}
     */
    sendTx(msgs: any[], fee: any, sequence: string | null): Promise<any>;
    /***************************************************
     *                   Tendermint
     ***************************************************/
    /**
     * Get the latest block
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getLatestBlock(timeout?: number): Promise<any>;
    /**
     * Get a block at a specific height
     * @param {Number} height the block's height
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getBlock(height: number, timeout?: number): Promise<any>;
    /**
     * Get the latest set of validators
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getLatestValidatorSet(timeout?: number): Promise<any>;
    /**
     * Get a set of validators at a specific block height
     * @param {Number} height the block's height
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getValidatorSet(height: number, timeout?: number): Promise<any>;
    /**
     * Checks a transaction hash for on-chain results
     * @param {String} txHash the transaction's hash
     * @param {Number} timeout milliseconds until the transaction will be considered not found
     * @return {Promise}
     */
    checkTxHash(txHash: string, timeout?: number): Promise<any>;
    /***************************************************
     *                   Cosmos SDK
     ***************************************************/
    /**
     * Get information about an account
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getAccount(address: string, timeout?: number): Promise<any>;
    /**
     * Get an account's balances
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getBalances(address: string, timeout?: number): Promise<Coin[] | undefined>;
    /**
     * Get an account's delegators reward
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getDistributionRewards(address: string, timeout?: number): Promise<any>;
    /**
     * Get an account's delegations
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getDelegations(address: string, timeout?: number): Promise<any>;
    /**
     * Get the total supply of coins on the chain
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getSupply(timeout?: number): Promise<any>;
    /**
     * Get the total supply of coins on the chain
     * @param {String} denom the name of the asset whose total supply will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getSupplyOf(denom: string, timeout?: number): Promise<any>;
    /**
     * Sends coins to an address
     * @param {String} recipient address that will receive coins
     * @param {String} coins amount of coins to send
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    transfer(recipient: string, coins: Coin[], fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                   Pricefeed
     ***************************************************/
    /**
     * Get the params of the pricefeed module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsPricefeed(timeout?: number): Promise<any>;
    /**
     * Get the current system price of an asset
     * @param {String} market asset's market identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getPrice(market: string, timeout?: number): Promise<any>;
    /**
     * Get all active oracle prices for an asset
     * @param {String} market asset's market identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getRawPrices(market: string, timeout?: number): Promise<any>;
    /**
     * Get all active markets
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getMarkets(timeout?: number): Promise<any>;
    /**
     * Get all active oracles for an asset
     * @param {String} denom asset's name
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getOracles(denom: string, timeout?: number): Promise<any>;
    /**
     * Allows oracles to post an asset's price to the pricefeed
     * @param {String} marketID the asset's on chain market ID, such as 'btc:usd'
     * @param {String} price the asset's price
     * @param {String} expiry time duration that this price is valid for
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    postPrice(marketID: string, price: string, expiry: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                    Auction
     ***************************************************/
    /**
     * Get the params of the auction module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsAuction(timeout?: number): Promise<any>;
    /**
     * Get auction by ID
     * @param {String} id auctions unique identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getAuction(id: string, timeout?: number): Promise<any>;
    /**
     * Get auctions, filterable by args.
     * @param {Object} args request args as JSON. Example: {type: "collateral", denom: "btc", owner: "kava1l0xsq2z7gqd7yly0g40y5836g0appumark77ny"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getAuctions(args?: {}, timeout?: number): Promise<any>;
    /**
     * Place a bid on an auction
     * @param {String} auctionID the unique ID of the auction
     * @param {String} amount the coins amount to bid
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    placeBid(auctionID: string, amount: Coin, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                     CDP
     ***************************************************/
    /**
     * Get the params of the cdp module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsCDP(timeout?: number): Promise<any>;
    /**
     * Get CDP if one exists for an owner and asset type
     * @param {String} owner address of the CDP's owner
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCDP(owner: string, collateralType: string, timeout?: number): Promise<any>;
    /**
     * Get all CDPs by filterable args
     * @param {Object} args request args as JSON. Example: {collateral-type: "btc-a", id: "52", ratio: "2.75", owner: "kava1l0xsq2z7gqd7yly0g40y5836g0appumark77ny"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCDPs(args?: {}, timeout?: number): Promise<any>;
    /**
     * Get all CDPs for an asset type
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCDPsByCollateralType(collateralType: string, timeout?: number): Promise<any>;
    /**
     * Get all CDPs for an asset that are under the collateralization ratio specified
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {String} ratio upper collateralization ratio limit of the query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCDPsByRatio(collateralType: string, ratio: string, timeout?: number): Promise<any>;
    /**
     * Get all deposits for the CDP with the specified owner and collateral type
     * @param {String} owner the address that owns the CDP
     * @param {String} collateralType denom of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getDeposits(owner: string, collateralType: string, timeout?: number): Promise<any>;
    /**
     * Create a collateralized debt position
     * @param {String} principal the coins that will be drawn as debt
     * @param {String} collateral the coins that will be held as collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    createCDP(principal: Coin, collateral: Coin, collateralType: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Deposit collateral into a collateralized debt position
     * @param {String} owner the owner of the CDP
     * @param {String} collateral the coins that will deposited as additional collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    deposit(owner: string, collateral: Coin, collateralType: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Withdraw collateral from a collateralized debt position
     * @param {String} owner the owner of the CDP
     * @param {String} collateral the coins that will withdrawn from existing collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    withdraw(owner: string, collateral: Coin, collateralType: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Draw additional debt from a collateralized debt position
     * @param {String} collateralType the CDP's collateral type
     * @param {String} principal the coins that will be drawn as additional principal
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    drawDebt(collateralType: string, principal: Coin, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Repay debt by returning principal to a collateralized debt position
     * @param {String} collateralType the CDP's collateral type
     * @param {String} payment the amount of pricipal to be repaid
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    repayDebt(collateralType: string, payment: Coin, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Attempt to liquidate a borrower that's over their loan-to-value ratio
     * @param {String} borrower the borrower to be liquidated
     * @param {String} collateralType the collateral type to be liquidated
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    liquidate(borrower: string, collateralType: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                     BEP3
     ***************************************************/
    /**
     * Get the params of the bep3 module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsBEP3(timeout?: number): Promise<any>;
    /**
     * Get a swap by its ID
     * @param {String} swapID the swap's unique identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getSwap(swapID: string, timeout?: number): Promise<any>;
    /**
     * Get swaps, filterable by args.
     * @param {Object} args request args as JSON. Example: {status: "Open", direction: "Incoming"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getSwaps(args?: {}, timeout?: number): Promise<any>;
    /**
     * Get an asset's total supply by its denom
     * @param {String} assetDenom the asset's denom
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getAssetSupply(assetDenom: string, timeout?: number): Promise<any>;
    /**
     * Get all supplies
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getAssetSupplies(timeout?: number): Promise<any>;
    /**
     * Create an atomic swap
     * @param {String} recipient the receiver's address on kava
     * @param {String} recipientOtherChain the receiver's address on the other chain
     * @param {String} senderOtherChain the sender's address on the other chain
     * @param {String} randomNumberHash resulting hex-encoded hash from sha256(timestamp, random number)
     * @param {String} timestamp the timestamp in unix, must be within 15-30 minutes of current time
     * @param {String} amount the amount in coins to be transferred
     * @param {String} heightSpan the number of blocks that this swap will be active/claimable
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    createSwap(recipient: string, recipientOtherChain: string, senderOtherChain: string, randomNumberHash: string, timestamp: number, amount: Coin[], heightSpan: number, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Claim an atomic swap
     * @param {String} swapID the swap's unique identifier
     * @param {String} randomNumber the secret random number used to generate this swap's random number hash
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    claimSwap(swapID: string, randomNumber: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Refund an atomic swap
     * @param {String} swapID the swap's unique identifier
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    refundSwap(swapID: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                    Incentive
     ***************************************************/
    /**
     * Get the params of the incentive module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsIncentive(timeout?: number): Promise<any>;
    /**
     * Get the claims of an address for a specific denom
     * @param {Number} args query arguments
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getRewards(args?: {}, timeout?: number): Promise<any>;
    /**
     * Claim USDX minting reward using a specific multiplier
     * @param {String} multiplierName the multiplier to claim with, such as 'small' or 'large'
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    claimUSDXMintingReward(multiplierName: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Claim Hard protocol reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    claimHardReward(denomsToClaim: DenomToClaim[], fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Claim Delegator reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    claimDelegatorReward(denomsToClaim: DenomToClaim[], fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Claim swap reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    claimSwapReward(denomsToClaim: DenomToClaim[], fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                    Committee
     ***************************************************/
    /**
     * Get the params of the committee module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsCommittee(timeout?: number): Promise<any>;
    /**
     * Get a committee by ID
     * @param {Number} committeeID unique identifier of the committee to be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCommittee(committeeID: number, timeout?: number): Promise<any>;
    /**
     * Get all committees
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCommittees(timeout?: number): Promise<any>;
    /**
     * Get all proposals by a committee
     * @param {Number} committeeID unique identifier of the committee whose proposals will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getCommitteeProposals(committeeID: number, timeout?: number): Promise<any>;
    /**
     * Get a proposal by ID
     * @param {Number} proposalID unique identifier of the proposal to be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getProposal(proposalID: number, timeout?: number): Promise<any>;
    /**
     * Get a proposal's proposer by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose proposer will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getProposer(proposalID: number, timeout?: number): Promise<any>;
    /**
     * Get a proposal's tally by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose tally will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getProposalTally(proposalID: number, timeout?: number): Promise<any>;
    /**
     * Get a proposal's votes by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose votes will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getProposalVotes(proposalID: number, timeout?: number): Promise<any>;
    /**
     * Submit a public proposal by a selected committee (must be a member)
     * @param {String} proposal the proposal to be submitted
     * @param {String} committeeID the unique identifier of the committee
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    submitCommitteeProposal(proposal: string, committeeID: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Vote on a public proposal by ID
     * @param {String} proposalID the unique identifier of the proposal
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    voteOnCommitteeProposal(proposalID: string, voteType: VoteType, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /***************************************************
     *                    Issuance
     ***************************************************/
    /**
     * Get the params of the issuance module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    getParamsIssuance(timeout?: number): Promise<any>;
    /**
     * Issues (mints) coins to a recipient address
     * @param {String} tokens coins to be issued
     * @param {String} receiver the recipient of the newly issued coins
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    issueTokens(tokens: Coin[], receiver: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Redeems tokens
     * @param {String} tokens coins to be redeemed
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    redeemTokens(tokens: Coin[], fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Blocks an address from interacting with a specific token denom
     * @param {String} denom the asset denom the address will be blocked from using
     * @param {String} blockedAddress the address to be blocked
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    blockAddress(denom: string, blockedAddress: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Unblocks an address that's blocked from interacting with a specific token denom
     * @param {String} denom the asset denom the address will be unblocked from using
     * @param {String} address the address to be unblocked
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    unblockAddress(denom: string, blockedAddress: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
    /**
     * Updates the paused/unpaused status for a specific token denom
     * @param {String} denom the asset denom whose status will be updated
     * @param {String} status bool representing the token's new active/inactive status
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    setPauseStatus(denom: string, status: string, fee?: {
        amount: never[];
        gas: string;
    }, sequence?: null): Promise<any>;
}
