"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KavaClient = void 0;
/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-explicit-any */
var sig = require('@kava-labs/sig');
var tx_1 = require("../tx");
var msg_1 = require("../msg");
var hard_1 = require("./hard");
var swap_1 = require("./swap");
var KAVA_PREFIX = 'kava';
var DERIVATION_PATH = "m/44'/459'/0'/0/0";
var DERIVATION_PATH_LEGACY = "m/44'/118'/0'/0/0";
var DEFAULT_FEE = { amount: [], gas: String(300000) };
var DEFAULT_CDP_FEE = { amount: [], gas: String(650000) };
var api = {
    txs: '/cosmos/tx/v1beta1/txs',
    nodeInfo: '/node_info',
    getBlock: '/blocks',
    getLatestBlock: '/blocks/latest',
    getLatestValidatorSet: '/validatorsets/latest',
    getValidatorSet: '/validatorsets/',
    getParamsPricefeed: '/pricefeed/parameters',
    getParamsAuction: '/auction/parameters',
    getParamsCDP: '/cdp/parameters',
    getParamsBEP3: '/bep3/parameters',
    getParamsIncentive: '/incentive/parameters',
    getParamsCommittee: '/committee/parameters',
    getParamsIssuance: '/issuance/parameters',
    getAccount: '/auth/accounts',
    getBalances: '/bank/balances',
    getSupply: '/supply/total',
    getMarkets: 'pricefeed/markets',
    getOracles: 'pricefeed/oracles',
    getPrice: '/pricefeed/price',
    getRawPrices: '/pricefeed/rawprices',
    getSwap: 'bep3/swap',
    getSwaps: '/bep3/swaps',
    getAssetSupply: 'bep3/supply',
    getAssetSupplies: 'bep3/supplies',
    getCDP: 'cdp/cdps/cdp',
    getCDPs: '/cdp/cdps',
    getCDPsByCollateralType: '/cdp/cdps/collateralType',
    getCDPsRatio: '/cdp/cdps/ratio',
    getDeposits: '/cdp/cdps/deposits',
    getAuction: '/auction/auctions',
    getAuctions: '/auction/auctions',
    getRewards: '/incentive/rewards',
    getCommittee: '/committee/committees',
    getCommittees: '/committee/committees',
    getProposal: '/committee/proposals',
    getDistributionRewards: '/distribution/delegators',
    getDelegations: '/staking/delegators',
};
/**
 * The Kava client.
 */
var KavaClient = /** @class */ (function () {
    /**
     * @param {String} server Kava public url
     */
    function KavaClient(server) {
        if (!server) {
            throw new Error('Kava server should not be null');
        }
        this.baseURI = server;
        this.broadcastMode = 'sync'; // default broadcast mode
        this.hard = new hard_1.Hard(this);
        this.swap = new swap_1.Swap(this);
    }
    /**
     * Initialize the client with the chain's ID. Asynchronous.
     * @return {Promise}
     */
    KavaClient.prototype.initChain = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!!this.chainID) return [3 /*break*/, 2];
                        return [4 /*yield*/, tx_1.tx.getTx(api.nodeInfo, this.baseURI)];
                    case 1:
                        res = _c.sent();
                        this.chainID = (_b = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.node_info) === null || _b === void 0 ? void 0 : _b.network;
                        _c.label = 2;
                    case 2: return [2 /*return*/, this];
                }
            });
        });
    };
    /**
     * Manually set the chain's ID
     * @param {String} chainID Kava chain ID
     */
    KavaClient.prototype.setChainID = function (chainID) {
        if (!chainID) {
            throw new Error('chainID cannot be undefined');
        }
        this.chainID = chainID;
        return this;
    };
    /**
     * Manually set the wallet's account number
     * @param {String} accNum Account number of the Kava address
     */
    KavaClient.prototype.setAccountNumber = function (accNum) {
        if (!accNum) {
            throw new Error('account number cannot be undefined');
        }
        this.accNum = String(accNum);
        return this;
    };
    /**
     * Set broadcast mode
     * @param {String} mode transaction broadcast mode
     */
    KavaClient.prototype.setBroadcastMode = function (mode) {
        if (!mode) {
            throw new Error('broadcast mode cannot be undefined');
        }
        if (mode != 'async' && mode != 'sync' && mode != 'block') {
            throw new Error([
                'invalid broadcast mode ',
                mode,
                ' - must be async, sync, or block',
            ].join(' '));
        }
        this.broadcastMode = String(mode);
        return this;
    };
    /**
     * Set the client's wallet which is used for signature generation
     * @param {String} mnemonic Kava address mnemonic
     * @param {String} password optional param for wallet password
     * @param {boolean} legacy optional param to use the legacy coin type
     * @return {Promise}
     */
    KavaClient.prototype.setWallet = function (mnemonic, password, legacy) {
        if (password === void 0) { password = ''; }
        if (legacy === void 0) { legacy = false; }
        if (!mnemonic) {
            throw new Error('mnemonic cannot be undefined');
        }
        var derivationPath = legacy ? DERIVATION_PATH_LEGACY : DERIVATION_PATH;
        this.wallet = sig.createWalletFromMnemonic(mnemonic, password, KAVA_PREFIX, derivationPath);
        return this;
    };
    /**
     * Load account number, sequence, and package with chain ID for signature
     * @param {String} sequence Kava address sequence
     * @return {Promise}
     */
    KavaClient.prototype.prepareSignInfo = function (sequence) {
        return __awaiter(this, void 0, void 0, function () {
            var signInfo, meta;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(sequence && this.accNum != null)) return [3 /*break*/, 1];
                        // Prepare signing info from manually set values
                        signInfo = {
                            chain_id: this.chainID,
                            account_number: String(this.accNum),
                            sequence: String(sequence),
                        };
                        return [3 /*break*/, 3];
                    case 1:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        return [4 /*yield*/, tx_1.tx.loadMetaData(this.wallet.address, this.baseURI)];
                    case 2:
                        meta = _a.sent();
                        // Select manually set values over automatically pulled values
                        signInfo = {
                            chain_id: this.chainID,
                            account_number: this.accNum != null
                                ? String(this.accNum)
                                : String(meta.account_number),
                            sequence: sequence ? String(sequence) : String(meta.sequence),
                        };
                        _a.label = 3;
                    case 3: return [2 /*return*/, signInfo];
                }
            });
        });
    };
    /**
     * Sends messages to the Kava blockchain
     * @param {Array} msgs an array of msgs to be sent
     * @param {Object} fee the transaction's fee that includes gas amount
     * @param {String} sequence account sequence
     * @return {Promise}
     */
    KavaClient.prototype.sendTx = function (msgs, fee, sequence) {
        return __awaiter(this, void 0, void 0, function () {
            var rawTx, signInfo, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawTx = msg_1.msg.cosmos.newStdTx(msgs, fee);
                        return [4 /*yield*/, this.prepareSignInfo(sequence)];
                    case 1:
                        signInfo = _a.sent();
                        signedTx = tx_1.tx.signTx(rawTx, signInfo, this.wallet);
                        return [4 /*yield*/, tx_1.tx.broadcastTx(signedTx, this.baseURI, this.broadcastMode)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                   Tendermint
     ***************************************************/
    /**
     * Get the latest block
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getLatestBlock = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getLatestBlock, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a block at a specific height
     * @param {Number} height the block's height
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getBlock = function (height, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getBlock + '/' + String(height);
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the latest set of validators
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getLatestValidatorSet = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getLatestValidatorSet, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a set of validators at a specific block height
     * @param {Number} height the block's height
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getValidatorSet = function (height, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getValidatorSet + '/' + String(height);
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks a transaction hash for on-chain results
     * @param {String} txHash the transaction's hash
     * @param {Number} timeout milliseconds until the transaction will be considered not found
     * @return {Promise}
     */
    KavaClient.prototype.checkTxHash = function (txHash, timeout) {
        var _a;
        if (timeout === void 0) { timeout = 10000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        path = api.txs + '/' + txHash;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 2:
                        res = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        throw new Error("tx not found: " + e_1);
                    case 4:
                        // If the transaction is found, check that it was accepted by the chain
                        try {
                            if ((_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.code) {
                                throw new Error("tx not accepted by chain: \"" + res.data.raw_log + "\"");
                            }
                        }
                        catch (e) {
                            console.log('\n' + e);
                        }
                        return [2 /*return*/, res.data];
                }
            });
        });
    };
    /***************************************************
     *                   Cosmos SDK
     ***************************************************/
    /**
     * Get information about an account
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getAccount = function (address, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getAccount + '/' + address;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get an account's balances
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getBalances = function (address, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getBalances + '/' + address;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get an account's delegators reward
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getDistributionRewards = function (address, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getDistributionRewards + '/' + address + '/rewards';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get an account's delegations
     * @param {String} address account to query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getDelegations = function (address, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getDelegations + '/' + address + '/delegations';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the total supply of coins on the chain
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getSupply = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getSupply, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the total supply of coins on the chain
     * @param {String} denom the name of the asset whose total supply will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getSupplyOf = function (denom, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getSupply + '/' + denom;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sends coins to an address
     * @param {String} recipient address that will receive coins
     * @param {String} coins amount of coins to send
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.transfer = function (recipient, coins, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgSend;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgSend = msg_1.msg.cosmos.newMsgSend(this.wallet.address, recipient, coins);
                        return [4 /*yield*/, this.sendTx([msgSend], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                   Pricefeed
     ***************************************************/
    /**
     * Get the params of the pricefeed module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsPricefeed = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsPricefeed, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the current system price of an asset
     * @param {String} market asset's market identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getPrice = function (market, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getPrice + '/' + market;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all active oracle prices for an asset
     * @param {String} market asset's market identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getRawPrices = function (market, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getRawPrices + '/' + market;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all active markets
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getMarkets = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getMarkets, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all active oracles for an asset
     * @param {String} denom asset's name
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getOracles = function (denom, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getOracles + '/' + denom;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Allows oracles to post an asset's price to the pricefeed
     * @param {String} marketID the asset's on chain market ID, such as 'btc:usd'
     * @param {String} price the asset's price
     * @param {String} expiry time duration that this price is valid for
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.postPrice = function (marketID, price, expiry, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgPostPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgPostPrice = msg_1.msg.kava.newMsgPostPrice(this.wallet.address, marketID, price, expiry);
                        return [4 /*yield*/, this.sendTx([msgPostPrice], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                    Auction
     ***************************************************/
    /**
     * Get the params of the auction module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsAuction = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsAuction, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get auction by ID
     * @param {String} id auctions unique identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getAuction = function (id, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getAuction + '/' + id;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get auctions, filterable by args.
     * @param {Object} args request args as JSON. Example: {type: "collateral", denom: "btc", owner: "kava1l0xsq2z7gqd7yly0g40y5836g0appumark77ny"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getAuctions = function (args, timeout) {
        if (args === void 0) { args = {}; }
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getAuctions, this.baseURI, timeout, args)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Place a bid on an auction
     * @param {String} auctionID the unique ID of the auction
     * @param {String} amount the coins amount to bid
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.placeBid = function (auctionID, amount, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgPlaceBid;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgPlaceBid = msg_1.msg.kava.newMsgPlaceBid(auctionID, this.wallet.address, amount);
                        return [4 /*yield*/, this.sendTx([msgPlaceBid], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                     CDP
     ***************************************************/
    /**
     * Get the params of the cdp module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsCDP = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsCDP, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get CDP if one exists for an owner and asset type
     * @param {String} owner address of the CDP's owner
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCDP = function (owner, collateralType, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getCDP + '/' + owner + '/' + collateralType;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all CDPs by filterable args
     * @param {Object} args request args as JSON. Example: {collateral-type: "btc-a", id: "52", ratio: "2.75", owner: "kava1l0xsq2z7gqd7yly0g40y5836g0appumark77ny"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCDPs = function (args, timeout) {
        if (args === void 0) { args = {}; }
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getCDPs, this.baseURI, timeout, args)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all CDPs for an asset type
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCDPsByCollateralType = function (collateralType, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getCDPsByCollateralType + '/' + collateralType;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all CDPs for an asset that are under the collateralization ratio specified
     * @param {String} collateralType type of the CDP's collateral asset
     * @param {String} ratio upper collateralization ratio limit of the query
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCDPsByRatio = function (collateralType, ratio, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getCDPsRatio + '/' + collateralType + '/' + ratio;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all deposits for the CDP with the specified owner and collateral type
     * @param {String} owner the address that owns the CDP
     * @param {String} collateralType denom of the CDP's collateral asset
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getDeposits = function (owner, collateralType, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getDeposits + '/' + owner + '/' + collateralType;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a collateralized debt position
     * @param {String} principal the coins that will be drawn as debt
     * @param {String} collateral the coins that will be held as collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.createCDP = function (principal, collateral, collateralType, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgCreateCDP;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgCreateCDP = msg_1.msg.kava.newMsgCreateCDP(this.wallet.address, principal, collateral, collateralType);
                        return [4 /*yield*/, this.sendTx([msgCreateCDP], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Deposit collateral into a collateralized debt position
     * @param {String} owner the owner of the CDP
     * @param {String} collateral the coins that will deposited as additional collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.deposit = function (owner, collateral, collateralType, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgDeposit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgDeposit = msg_1.msg.kava.newMsgDeposit(owner, this.wallet.address, collateral, collateralType);
                        return [4 /*yield*/, this.sendTx([msgDeposit], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Withdraw collateral from a collateralized debt position
     * @param {String} owner the owner of the CDP
     * @param {String} collateral the coins that will withdrawn from existing collateral
     * @param {String} collateralType the CDP's collateral type
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.withdraw = function (owner, collateral, collateralType, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgWithdraw;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgWithdraw = msg_1.msg.kava.newMsgWithdraw(owner, this.wallet.address, collateral, collateralType);
                        return [4 /*yield*/, this.sendTx([msgWithdraw], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Draw additional debt from a collateralized debt position
     * @param {String} collateralType the CDP's collateral type
     * @param {String} principal the coins that will be drawn as additional principal
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.drawDebt = function (collateralType, principal, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgDrawDebt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgDrawDebt = msg_1.msg.kava.newMsgDrawDebt(this.wallet.address, collateralType, principal);
                        return [4 /*yield*/, this.sendTx([msgDrawDebt], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Repay debt by returning principal to a collateralized debt position
     * @param {String} collateralType the CDP's collateral type
     * @param {String} payment the amount of pricipal to be repaid
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.repayDebt = function (collateralType, payment, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgRepayDebt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgRepayDebt = msg_1.msg.kava.newMsgRepayDebt(this.wallet.address, collateralType, payment);
                        return [4 /*yield*/, this.sendTx([msgRepayDebt], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Attempt to liquidate a borrower that's over their loan-to-value ratio
     * @param {String} borrower the borrower to be liquidated
     * @param {String} collateralType the collateral type to be liquidated
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.liquidate = function (borrower, collateralType, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_CDP_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgLiquidate;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgLiquidate = msg_1.msg.kava.newMsgLiquidate(this.wallet.address, borrower, collateralType);
                        return [4 /*yield*/, this.sendTx([msgLiquidate], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                     BEP3
     ***************************************************/
    /**
     * Get the params of the bep3 module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsBEP3 = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsBEP3, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a swap by its ID
     * @param {String} swapID the swap's unique identifier
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getSwap = function (swapID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getSwap + '/' + swapID;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get swaps, filterable by args.
     * @param {Object} args request args as JSON. Example: {status: "Open", direction: "Incoming"}
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getSwaps = function (args, timeout) {
        if (args === void 0) { args = {}; }
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getSwaps, this.baseURI, timeout, args)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get an asset's total supply by its denom
     * @param {String} assetDenom the asset's denom
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getAssetSupply = function (assetDenom, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getAssetSupply + '/' + assetDenom;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all supplies
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getAssetSupplies = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getAssetSupplies, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create an atomic swap
     * @param {String} recipient the receiver's address on kava
     * @param {String} recipientOtherChain the receiver's address on the other chain
     * @param {String} senderOtherChain the sender's address on the other chain
     * @param {String} randomNumberHash resulting hex-encoded hash from sha256(timestamp, random number)
     * @param {String} timestamp the timestamp in unix, must be within 15-30 minutes of current time
     * @param {String} amount the amount in coins to be transferred
     * @param {String} heightSpan the number of blocks that this swap will be active/claimable
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.createSwap = function (recipient, recipientOtherChain, senderOtherChain, randomNumberHash, timestamp, amount, heightSpan, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgCreateAtomicSwap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgCreateAtomicSwap = msg_1.msg.kava.newMsgCreateAtomicSwap(this.wallet.address, recipient, recipientOtherChain, senderOtherChain, randomNumberHash.toUpperCase(), timestamp, amount, heightSpan);
                        return [4 /*yield*/, this.sendTx([msgCreateAtomicSwap], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Claim an atomic swap
     * @param {String} swapID the swap's unique identifier
     * @param {String} randomNumber the secret random number used to generate this swap's random number hash
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.claimSwap = function (swapID, randomNumber, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgClaimAtomicSwap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgClaimAtomicSwap = msg_1.msg.kava.newMsgClaimAtomicSwap(this.wallet.address, swapID.toUpperCase(), randomNumber.toUpperCase());
                        return [4 /*yield*/, this.sendTx([msgClaimAtomicSwap], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Refund an atomic swap
     * @param {String} swapID the swap's unique identifier
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.refundSwap = function (swapID, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgRefundAtomicSwap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgRefundAtomicSwap = msg_1.msg.kava.newMsgRefundAtomicSwap(this.wallet.address, swapID.toUpperCase());
                        return [4 /*yield*/, this.sendTx([msgRefundAtomicSwap], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                    Incentive
     ***************************************************/
    /**
     * Get the params of the incentive module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsIncentive = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsIncentive, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the claims of an address for a specific denom
     * @param {Number} args query arguments
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getRewards = function (args, timeout) {
        if (args === void 0) { args = {}; }
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getRewards;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout, args)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Claim USDX minting reward using a specific multiplier
     * @param {String} multiplierName the multiplier to claim with, such as 'small' or 'large'
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.claimUSDXMintingReward = function (multiplierName, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgClaimUSDXMintingReward;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgClaimUSDXMintingReward = msg_1.msg.kava.newMsgClaimUSDXMintingReward(this.wallet.address, multiplierName);
                        return [4 /*yield*/, this.sendTx([msgClaimUSDXMintingReward], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Claim Hard protocol reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.claimHardReward = function (denomsToClaim, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgClaimHardReward;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgClaimHardReward = msg_1.msg.kava.newMsgClaimHardReward(this.wallet.address, denomsToClaim);
                        return [4 /*yield*/, this.sendTx([msgClaimHardReward], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Claim Delegator reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.claimDelegatorReward = function (denomsToClaim, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgClaimDelegatorReward;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgClaimDelegatorReward = msg_1.msg.kava.newMsgClaimDelegatorReward(this.wallet.address, denomsToClaim);
                        return [4 /*yield*/, this.sendTx([msgClaimDelegatorReward], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Claim swap reward using a specific multiplier and denoms
     * @params {Array} choose which denom(s) of your rewards that you would like to claim
     * and at which multiplier you claim them
     * [{ denom: 'hard', multiplierName: 'large'}, { denom: 'ukava', multiplierName: 'small' }]
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.claimSwapReward = function (denomsToClaim, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgClaimSwapReward;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgClaimSwapReward = msg_1.msg.kava.newMsgClaimSwapReward(this.wallet.address, denomsToClaim);
                        return [4 /*yield*/, this.sendTx([msgClaimSwapReward], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                    Committee
     ***************************************************/
    /**
     * Get the params of the committee module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsCommittee = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsCommittee, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a committee by ID
     * @param {Number} committeeID unique identifier of the committee to be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCommittee = function (committeeID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getCommittee + '/' + committeeID;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all committees
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCommittees = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getCommittees, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get all proposals by a committee
     * @param {Number} committeeID unique identifier of the committee whose proposals will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getCommitteeProposals = function (committeeID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getCommittee + '/' + committeeID + '/proposals';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a proposal by ID
     * @param {Number} proposalID unique identifier of the proposal to be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getProposal = function (proposalID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getProposal + '/' + proposalID;
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a proposal's proposer by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose proposer will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getProposer = function (proposalID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getProposal + '/' + proposalID + '/proposer';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a proposal's tally by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose tally will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getProposalTally = function (proposalID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getProposal + '/' + proposalID + '/tally';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a proposal's votes by proposal ID
     * @param {Number} proposalID unique identifier of the proposal whose votes will be queried
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getProposalVotes = function (proposalID, timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var path, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = api.getProposal + '/' + proposalID + '/votes';
                        return [4 /*yield*/, tx_1.tx.getTx(path, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Submit a public proposal by a selected committee (must be a member)
     * @param {String} proposal the proposal to be submitted
     * @param {String} committeeID the unique identifier of the committee
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.submitCommitteeProposal = function (proposal, committeeID, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgSubmitProposal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgSubmitProposal = msg_1.msg.kava.newMsgSubmitProposal(proposal, this.wallet.address, committeeID);
                        return [4 /*yield*/, this.sendTx([msgSubmitProposal], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Vote on a public proposal by ID
     * @param {String} proposalID the unique identifier of the proposal
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.voteOnCommitteeProposal = function (proposalID, voteType, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgVote;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgVote = msg_1.msg.kava.newMsgVote(proposalID, this.wallet.address, voteType);
                        return [4 /*yield*/, this.sendTx([msgVote], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /***************************************************
     *                    Issuance
     ***************************************************/
    /**
     * Get the params of the issuance module
     * @param {Number} timeout request is attempted every 1000 milliseconds until millisecond timeout is reached
     * @return {Promise}
     */
    KavaClient.prototype.getParamsIssuance = function (timeout) {
        if (timeout === void 0) { timeout = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, tx_1.tx.getTx(api.getParamsIssuance, this.baseURI, timeout)];
                    case 1:
                        res = _a.sent();
                        if (res && res.data) {
                            return [2 /*return*/, res.data.result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Issues (mints) coins to a recipient address
     * @param {String} tokens coins to be issued
     * @param {String} receiver the recipient of the newly issued coins
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.issueTokens = function (tokens, receiver, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgIssueTokens;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgIssueTokens = msg_1.msg.kava.newMsgIssueTokens(this.wallet.address, tokens, receiver);
                        return [4 /*yield*/, this.sendTx([msgIssueTokens], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Redeems tokens
     * @param {String} tokens coins to be redeemed
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.redeemTokens = function (tokens, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgRedeemTokens;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgRedeemTokens = msg_1.msg.kava.newMsgRedeemTokens(this.wallet.address, tokens);
                        return [4 /*yield*/, this.sendTx([msgRedeemTokens], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Blocks an address from interacting with a specific token denom
     * @param {String} denom the asset denom the address will be blocked from using
     * @param {String} blockedAddress the address to be blocked
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.blockAddress = function (denom, blockedAddress, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgBlockAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgBlockAddress = msg_1.msg.kava.newMsgBlockAddress(this.wallet.address, denom, blockedAddress);
                        return [4 /*yield*/, this.sendTx([msgBlockAddress], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Unblocks an address that's blocked from interacting with a specific token denom
     * @param {String} denom the asset denom the address will be unblocked from using
     * @param {String} address the address to be unblocked
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.unblockAddress = function (denom, blockedAddress, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgUnblockAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgUnblockAddress = msg_1.msg.kava.newMsgUnblockAddress(this.wallet.address, denom, blockedAddress);
                        return [4 /*yield*/, this.sendTx([msgUnblockAddress], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Updates the paused/unpaused status for a specific token denom
     * @param {String} denom the asset denom whose status will be updated
     * @param {String} status bool representing the token's new active/inactive status
     * @param {Object} fee optional fee consisting of { amount: [Coins], gas: String(Number) }
     * @param {String} sequence optional account sequence
     * @return {Promise}
     */
    KavaClient.prototype.setPauseStatus = function (denom, status, fee, sequence) {
        if (fee === void 0) { fee = DEFAULT_FEE; }
        if (sequence === void 0) { sequence = null; }
        return __awaiter(this, void 0, void 0, function () {
            var msgSetPauseStatus;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet) {
                            throw Error('Wallet has not yet been initialized');
                        }
                        msgSetPauseStatus = msg_1.msg.kava.newMsgSetPauseStatus(this.wallet.address, denom, status);
                        return [4 /*yield*/, this.sendTx([msgSetPauseStatus], fee, sequence)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return KavaClient;
}());
exports.KavaClient = KavaClient;
