import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { Params } from '../../../kava/earn/v1beta1/params';
import { PageRequest, PageResponse } from '../../../cosmos/base/query/v1beta1/pagination';
import { StrategyType } from '../../../kava/earn/v1beta1/strategy';
import { VaultShare } from '../../../kava/earn/v1beta1/vault';
import { Coin } from '../../../cosmos/base/v1beta1/coin';
export declare const protobufPackage = "kava.earn.v1beta1";
/** QueryParamsRequest defines the request type for querying x/earn parameters. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse defines the response type for querying x/earn parameters. */
export interface QueryParamsResponse {
    /** params represents the earn module parameters */
    params?: Params;
}
/** QueryVaultsRequest is the request type for the Query/Vaults RPC method. */
export interface QueryVaultsRequest {
}
/** QueryVaultsResponse is the response type for the Query/Vaults RPC method. */
export interface QueryVaultsResponse {
    /** vaults represents the earn module vaults */
    vaults: VaultResponse[];
}
/** QueryVaultRequest is the request type for the Query/Vault RPC method. */
export interface QueryVaultRequest {
    /** vault filters vault by denom */
    denom: string;
}
/** QueryVaultResponse is the response type for the Query/Vault RPC method. */
export interface QueryVaultResponse {
    /** vault represents the queried earn module vault */
    vault?: VaultResponse;
}
/** VaultResponse is the response type for a vault. */
export interface VaultResponse {
    /** denom represents the denom of the vault */
    denom: string;
    /** VaultStrategy is the strategy used for this vault. */
    strategies: StrategyType[];
    /**
     * IsPrivateVault is true if the vault only allows depositors contained in
     * AllowedDepositors.
     */
    isPrivateVault: boolean;
    /**
     * AllowedDepositors is a list of addresses that are allowed to deposit to
     * this vault if IsPrivateVault is true. Addresses not contained in this list
     * are not allowed to deposit into this vault. If IsPrivateVault is false,
     * this should be empty and ignored.
     */
    allowedDepositors: string[];
    /** TotalShares is the total amount of shares issued to depositors. */
    totalShares: string;
    /**
     * TotalValue is the total value of denom coins supplied to the vault if the
     * vault were to be liquidated.
     */
    totalValue: string;
}
/** QueryDepositsRequest is the request type for the Query/Deposits RPC method. */
export interface QueryDepositsRequest {
    /** depositor optionally filters deposits by depositor */
    depositor: string;
    /** denom optionally filters deposits by vault denom */
    denom: string;
    /** respond with vault value in ukava for bkava vaults */
    valueInStakedTokens: boolean;
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest;
}
/** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
export interface QueryDepositsResponse {
    /** deposits returns the deposits matching the requested parameters */
    deposits: DepositResponse[];
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse;
}
/** DepositResponse defines a deposit query response type. */
export interface DepositResponse {
    /** depositor represents the owner of the deposit. */
    depositor: string;
    /** Shares represent the issued shares from their corresponding vaults. */
    shares: VaultShare[];
    /**
     * Value represents the total accumulated value of denom coins supplied to
     * vaults. This may be greater than or equal to amount_supplied depending on
     * the strategy.
     */
    value: Coin[];
}
export declare const QueryParamsRequest: {
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
export declare const QueryParamsResponse: {
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            allowedVaults?: {
                denom?: string | undefined;
                strategies?: StrategyType[] | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: Uint8Array[] | undefined;
            }[] | undefined;
        } | undefined;
    } & {
        params?: ({
            allowedVaults?: {
                denom?: string | undefined;
                strategies?: StrategyType[] | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: Uint8Array[] | undefined;
            }[] | undefined;
        } & {
            allowedVaults?: ({
                denom?: string | undefined;
                strategies?: StrategyType[] | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: Uint8Array[] | undefined;
            }[] & ({
                denom?: string | undefined;
                strategies?: StrategyType[] | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: Uint8Array[] | undefined;
            } & {
                denom?: string | undefined;
                strategies?: (StrategyType[] & StrategyType[] & Record<Exclude<keyof I["params"]["allowedVaults"][number]["strategies"], keyof StrategyType[]>, never>) | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["params"]["allowedVaults"][number]["allowedDepositors"], keyof Uint8Array[]>, never>) | undefined;
            } & Record<Exclude<keyof I["params"]["allowedVaults"][number], keyof import("../../../kava/earn/v1beta1/vault").AllowedVault>, never>)[] & Record<Exclude<keyof I["params"]["allowedVaults"], keyof {
                denom?: string | undefined;
                strategies?: StrategyType[] | undefined;
                isPrivateVault?: boolean | undefined;
                allowedDepositors?: Uint8Array[] | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["params"], "allowedVaults">, never>) | undefined;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
export declare const QueryVaultsRequest: {
    encode(_: QueryVaultsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryVaultsRequest;
    fromJSON(_: any): QueryVaultsRequest;
    toJSON(_: QueryVaultsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryVaultsRequest;
};
export declare const QueryVaultsResponse: {
    encode(message: QueryVaultsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryVaultsResponse;
    fromJSON(object: any): QueryVaultsResponse;
    toJSON(message: QueryVaultsResponse): unknown;
    fromPartial<I extends {
        vaults?: {
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        }[] | undefined;
    } & {
        vaults?: ({
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        } & {
            denom?: string | undefined;
            strategies?: (StrategyType[] & StrategyType[] & Record<Exclude<keyof I["vaults"][number]["strategies"], keyof StrategyType[]>, never>) | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: (string[] & string[] & Record<Exclude<keyof I["vaults"][number]["allowedDepositors"], keyof string[]>, never>) | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        } & Record<Exclude<keyof I["vaults"][number], keyof VaultResponse>, never>)[] & Record<Exclude<keyof I["vaults"], keyof {
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "vaults">, never>>(object: I): QueryVaultsResponse;
};
export declare const QueryVaultRequest: {
    encode(message: QueryVaultRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryVaultRequest;
    fromJSON(object: any): QueryVaultRequest;
    toJSON(message: QueryVaultRequest): unknown;
    fromPartial<I extends {
        denom?: string | undefined;
    } & {
        denom?: string | undefined;
    } & Record<Exclude<keyof I, "denom">, never>>(object: I): QueryVaultRequest;
};
export declare const QueryVaultResponse: {
    encode(message: QueryVaultResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryVaultResponse;
    fromJSON(object: any): QueryVaultResponse;
    toJSON(message: QueryVaultResponse): unknown;
    fromPartial<I extends {
        vault?: {
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        } | undefined;
    } & {
        vault?: ({
            denom?: string | undefined;
            strategies?: StrategyType[] | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: string[] | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        } & {
            denom?: string | undefined;
            strategies?: (StrategyType[] & StrategyType[] & Record<Exclude<keyof I["vault"]["strategies"], keyof StrategyType[]>, never>) | undefined;
            isPrivateVault?: boolean | undefined;
            allowedDepositors?: (string[] & string[] & Record<Exclude<keyof I["vault"]["allowedDepositors"], keyof string[]>, never>) | undefined;
            totalShares?: string | undefined;
            totalValue?: string | undefined;
        } & Record<Exclude<keyof I["vault"], keyof VaultResponse>, never>) | undefined;
    } & Record<Exclude<keyof I, "vault">, never>>(object: I): QueryVaultResponse;
};
export declare const VaultResponse: {
    encode(message: VaultResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): VaultResponse;
    fromJSON(object: any): VaultResponse;
    toJSON(message: VaultResponse): unknown;
    fromPartial<I extends {
        denom?: string | undefined;
        strategies?: StrategyType[] | undefined;
        isPrivateVault?: boolean | undefined;
        allowedDepositors?: string[] | undefined;
        totalShares?: string | undefined;
        totalValue?: string | undefined;
    } & {
        denom?: string | undefined;
        strategies?: (StrategyType[] & StrategyType[] & Record<Exclude<keyof I["strategies"], keyof StrategyType[]>, never>) | undefined;
        isPrivateVault?: boolean | undefined;
        allowedDepositors?: (string[] & string[] & Record<Exclude<keyof I["allowedDepositors"], keyof string[]>, never>) | undefined;
        totalShares?: string | undefined;
        totalValue?: string | undefined;
    } & Record<Exclude<keyof I, keyof VaultResponse>, never>>(object: I): VaultResponse;
};
export declare const QueryDepositsRequest: {
    encode(message: QueryDepositsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryDepositsRequest;
    fromJSON(object: any): QueryDepositsRequest;
    toJSON(message: QueryDepositsRequest): unknown;
    fromPartial<I extends {
        depositor?: string | undefined;
        denom?: string | undefined;
        valueInStakedTokens?: boolean | undefined;
        pagination?: {
            key?: Uint8Array | undefined;
            offset?: string | number | Long | undefined;
            limit?: string | number | Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } | undefined;
    } & {
        depositor?: string | undefined;
        denom?: string | undefined;
        valueInStakedTokens?: boolean | undefined;
        pagination?: ({
            key?: Uint8Array | undefined;
            offset?: string | number | Long | undefined;
            limit?: string | number | Long | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & {
            key?: Uint8Array | undefined;
            offset?: string | number | (Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long) => Long;
                and: (other: string | number | Long) => Long;
                compare: (other: string | number | Long) => number;
                comp: (other: string | number | Long) => number;
                divide: (divisor: string | number | Long) => Long;
                div: (divisor: string | number | Long) => Long;
                equals: (other: string | number | Long) => boolean;
                eq: (other: string | number | Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long) => boolean;
                gt: (other: string | number | Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long) => boolean;
                gte: (other: string | number | Long) => boolean;
                ge: (other: string | number | Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | Long) => boolean;
                lt: (other: string | number | Long) => boolean;
                lessThanOrEqual: (other: string | number | Long) => boolean;
                lte: (other: string | number | Long) => boolean;
                le: (other: string | number | Long) => boolean;
                modulo: (other: string | number | Long) => Long;
                mod: (other: string | number | Long) => Long;
                rem: (other: string | number | Long) => Long;
                multiply: (multiplier: string | number | Long) => Long;
                mul: (multiplier: string | number | Long) => Long;
                negate: () => Long;
                neg: () => Long;
                not: () => Long;
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | Long) => boolean;
                neq: (other: string | number | Long) => boolean;
                ne: (other: string | number | Long) => boolean;
                or: (other: string | number | Long) => Long;
                shiftLeft: (numBits: number | Long) => Long;
                shl: (numBits: number | Long) => Long;
                shiftRight: (numBits: number | Long) => Long;
                shr: (numBits: number | Long) => Long;
                shiftRightUnsigned: (numBits: number | Long) => Long;
                shru: (numBits: number | Long) => Long;
                shr_u: (numBits: number | Long) => Long;
                rotateLeft: (numBits: number | Long) => Long;
                rotl: (numBits: number | Long) => Long;
                rotateRight: (numBits: number | Long) => Long;
                rotr: (numBits: number | Long) => Long;
                subtract: (subtrahend: string | number | Long) => Long;
                sub: (subtrahend: string | number | Long) => Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long;
                xor: (other: string | number | Long) => Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long>, never>) | undefined;
            limit?: string | number | (Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long) => Long;
                and: (other: string | number | Long) => Long;
                compare: (other: string | number | Long) => number;
                comp: (other: string | number | Long) => number;
                divide: (divisor: string | number | Long) => Long;
                div: (divisor: string | number | Long) => Long;
                equals: (other: string | number | Long) => boolean;
                eq: (other: string | number | Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long) => boolean;
                gt: (other: string | number | Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long) => boolean;
                gte: (other: string | number | Long) => boolean;
                ge: (other: string | number | Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | Long) => boolean;
                lt: (other: string | number | Long) => boolean;
                lessThanOrEqual: (other: string | number | Long) => boolean;
                lte: (other: string | number | Long) => boolean;
                le: (other: string | number | Long) => boolean;
                modulo: (other: string | number | Long) => Long;
                mod: (other: string | number | Long) => Long;
                rem: (other: string | number | Long) => Long;
                multiply: (multiplier: string | number | Long) => Long;
                mul: (multiplier: string | number | Long) => Long;
                negate: () => Long;
                neg: () => Long;
                not: () => Long;
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | Long) => boolean;
                neq: (other: string | number | Long) => boolean;
                ne: (other: string | number | Long) => boolean;
                or: (other: string | number | Long) => Long;
                shiftLeft: (numBits: number | Long) => Long;
                shl: (numBits: number | Long) => Long;
                shiftRight: (numBits: number | Long) => Long;
                shr: (numBits: number | Long) => Long;
                shiftRightUnsigned: (numBits: number | Long) => Long;
                shru: (numBits: number | Long) => Long;
                shr_u: (numBits: number | Long) => Long;
                rotateLeft: (numBits: number | Long) => Long;
                rotl: (numBits: number | Long) => Long;
                rotateRight: (numBits: number | Long) => Long;
                rotr: (numBits: number | Long) => Long;
                subtract: (subtrahend: string | number | Long) => Long;
                sub: (subtrahend: string | number | Long) => Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long;
                xor: (other: string | number | Long) => Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long>, never>) | undefined;
            countTotal?: boolean | undefined;
            reverse?: boolean | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof QueryDepositsRequest>, never>>(object: I): QueryDepositsRequest;
};
export declare const QueryDepositsResponse: {
    encode(message: QueryDepositsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): QueryDepositsResponse;
    fromJSON(object: any): QueryDepositsResponse;
    toJSON(message: QueryDepositsResponse): unknown;
    fromPartial<I extends {
        deposits?: {
            depositor?: string | undefined;
            shares?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
            value?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
        }[] | undefined;
        pagination?: {
            nextKey?: Uint8Array | undefined;
            total?: string | number | Long | undefined;
        } | undefined;
    } & {
        deposits?: ({
            depositor?: string | undefined;
            shares?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
            value?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
        }[] & ({
            depositor?: string | undefined;
            shares?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
            value?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
        } & {
            depositor?: string | undefined;
            shares?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            }[] & ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & Record<Exclude<keyof I["deposits"][number]["shares"][number], keyof VaultShare>, never>)[] & Record<Exclude<keyof I["deposits"][number]["shares"], keyof {
                denom?: string | undefined;
                amount?: string | undefined;
            }[]>, never>) | undefined;
            value?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            }[] & ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & Record<Exclude<keyof I["deposits"][number]["value"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["deposits"][number]["value"], keyof {
                denom?: string | undefined;
                amount?: string | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["deposits"][number], keyof DepositResponse>, never>)[] & Record<Exclude<keyof I["deposits"], keyof {
            depositor?: string | undefined;
            shares?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
            value?: {
                denom?: string | undefined;
                amount?: string | undefined;
            }[] | undefined;
        }[]>, never>) | undefined;
        pagination?: ({
            nextKey?: Uint8Array | undefined;
            total?: string | number | Long | undefined;
        } & {
            nextKey?: Uint8Array | undefined;
            total?: string | number | (Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long) => Long;
                and: (other: string | number | Long) => Long;
                compare: (other: string | number | Long) => number;
                comp: (other: string | number | Long) => number;
                divide: (divisor: string | number | Long) => Long;
                div: (divisor: string | number | Long) => Long;
                equals: (other: string | number | Long) => boolean;
                eq: (other: string | number | Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long) => boolean;
                gt: (other: string | number | Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long) => boolean;
                gte: (other: string | number | Long) => boolean;
                ge: (other: string | number | Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | Long) => boolean;
                lt: (other: string | number | Long) => boolean;
                lessThanOrEqual: (other: string | number | Long) => boolean;
                lte: (other: string | number | Long) => boolean;
                le: (other: string | number | Long) => boolean;
                modulo: (other: string | number | Long) => Long;
                mod: (other: string | number | Long) => Long;
                rem: (other: string | number | Long) => Long;
                multiply: (multiplier: string | number | Long) => Long;
                mul: (multiplier: string | number | Long) => Long;
                negate: () => Long;
                neg: () => Long;
                not: () => Long;
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | Long) => boolean;
                neq: (other: string | number | Long) => boolean;
                ne: (other: string | number | Long) => boolean;
                or: (other: string | number | Long) => Long;
                shiftLeft: (numBits: number | Long) => Long;
                shl: (numBits: number | Long) => Long;
                shiftRight: (numBits: number | Long) => Long;
                shr: (numBits: number | Long) => Long;
                shiftRightUnsigned: (numBits: number | Long) => Long;
                shru: (numBits: number | Long) => Long;
                shr_u: (numBits: number | Long) => Long;
                rotateLeft: (numBits: number | Long) => Long;
                rotl: (numBits: number | Long) => Long;
                rotateRight: (numBits: number | Long) => Long;
                rotr: (numBits: number | Long) => Long;
                subtract: (subtrahend: string | number | Long) => Long;
                sub: (subtrahend: string | number | Long) => Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long;
                xor: (other: string | number | Long) => Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long>, never>) | undefined;
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof QueryDepositsResponse>, never>>(object: I): QueryDepositsResponse;
};
export declare const DepositResponse: {
    encode(message: DepositResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): DepositResponse;
    fromJSON(object: any): DepositResponse;
    toJSON(message: DepositResponse): unknown;
    fromPartial<I extends {
        depositor?: string | undefined;
        shares?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
        value?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
    } & {
        depositor?: string | undefined;
        shares?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["shares"][number], keyof VaultShare>, never>)[] & Record<Exclude<keyof I["shares"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>, never>) | undefined;
        value?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["value"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["value"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof DepositResponse>, never>>(object: I): DepositResponse;
};
/** Query defines the gRPC querier service for earn module */
export interface Query {
    /** Params queries all parameters of the earn module. */
    Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Vaults queries all vaults */
    Vaults(request: QueryVaultsRequest): Promise<QueryVaultsResponse>;
    /** Vault queries a single vault based on the vault denom */
    Vault(request: QueryVaultRequest): Promise<QueryVaultResponse>;
    /** Deposits queries deposit details based on depositor address and vault */
    Deposits(request: QueryDepositsRequest): Promise<QueryDepositsResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
    Vaults(request: QueryVaultsRequest): Promise<QueryVaultsResponse>;
    Vault(request: QueryVaultRequest): Promise<QueryVaultResponse>;
    Deposits(request: QueryDepositsRequest): Promise<QueryDepositsResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
