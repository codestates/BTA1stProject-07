import Long from 'long';
import _m0 from 'protobufjs/minimal';
export declare const protobufPackage = "kava.incentive.v1beta1";
/**
 * Selection is a pair of denom and multiplier name. It holds the choice of multiplier a user makes when they claim a
 * denom.
 */
export interface Selection {
    denom: string;
    multiplierName: string;
}
/** MsgClaimUSDXMintingReward message type used to claim USDX minting rewards */
export interface MsgClaimUSDXMintingReward {
    sender: string;
    multiplierName: string;
}
/** MsgClaimUSDXMintingRewardResponse defines the Msg/ClaimUSDXMintingReward response type. */
export interface MsgClaimUSDXMintingRewardResponse {
}
/** MsgClaimHardReward message type used to claim Hard liquidity provider rewards */
export interface MsgClaimHardReward {
    sender: string;
    denomsToClaim: Selection[];
}
/** MsgClaimHardRewardResponse defines the Msg/ClaimHardReward response type. */
export interface MsgClaimHardRewardResponse {
}
/** MsgClaimDelegatorReward message type used to claim delegator rewards */
export interface MsgClaimDelegatorReward {
    sender: string;
    denomsToClaim: Selection[];
}
/** MsgClaimDelegatorRewardResponse defines the Msg/ClaimDelegatorReward response type. */
export interface MsgClaimDelegatorRewardResponse {
}
/** MsgClaimSwapReward message type used to claim delegator rewards */
export interface MsgClaimSwapReward {
    sender: string;
    denomsToClaim: Selection[];
}
/** MsgClaimSwapRewardResponse defines the Msg/ClaimSwapReward response type. */
export interface MsgClaimSwapRewardResponse {
}
/** MsgClaimSavingsReward message type used to claim savings rewards */
export interface MsgClaimSavingsReward {
    sender: string;
    denomsToClaim: Selection[];
}
/** MsgClaimSavingsRewardResponse defines the Msg/ClaimSavingsReward response type. */
export interface MsgClaimSavingsRewardResponse {
}
/** MsgClaimEarnReward message type used to claim earn rewards */
export interface MsgClaimEarnReward {
    sender: string;
    denomsToClaim: Selection[];
}
/** MsgClaimEarnRewardResponse defines the Msg/ClaimEarnReward response type. */
export interface MsgClaimEarnRewardResponse {
}
export declare const Selection: {
    encode(message: Selection, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Selection;
    fromJSON(object: any): Selection;
    toJSON(message: Selection): unknown;
    fromPartial<I extends {
        denom?: string | undefined;
        multiplierName?: string | undefined;
    } & {
        denom?: string | undefined;
        multiplierName?: string | undefined;
    } & Record<Exclude<keyof I, keyof Selection>, never>>(object: I): Selection;
};
export declare const MsgClaimUSDXMintingReward: {
    encode(message: MsgClaimUSDXMintingReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimUSDXMintingReward;
    fromJSON(object: any): MsgClaimUSDXMintingReward;
    toJSON(message: MsgClaimUSDXMintingReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        multiplierName?: string | undefined;
    } & {
        sender?: string | undefined;
        multiplierName?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimUSDXMintingReward>, never>>(object: I): MsgClaimUSDXMintingReward;
};
export declare const MsgClaimUSDXMintingRewardResponse: {
    encode(_: MsgClaimUSDXMintingRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimUSDXMintingRewardResponse;
    fromJSON(_: any): MsgClaimUSDXMintingRewardResponse;
    toJSON(_: MsgClaimUSDXMintingRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimUSDXMintingRewardResponse;
};
export declare const MsgClaimHardReward: {
    encode(message: MsgClaimHardReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimHardReward;
    fromJSON(object: any): MsgClaimHardReward;
    toJSON(message: MsgClaimHardReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        denomsToClaim?: {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] | undefined;
    } & {
        sender?: string | undefined;
        denomsToClaim?: ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & Record<Exclude<keyof I["denomsToClaim"][number], keyof Selection>, never>)[] & Record<Exclude<keyof I["denomsToClaim"], keyof {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimHardReward>, never>>(object: I): MsgClaimHardReward;
};
export declare const MsgClaimHardRewardResponse: {
    encode(_: MsgClaimHardRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimHardRewardResponse;
    fromJSON(_: any): MsgClaimHardRewardResponse;
    toJSON(_: MsgClaimHardRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimHardRewardResponse;
};
export declare const MsgClaimDelegatorReward: {
    encode(message: MsgClaimDelegatorReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimDelegatorReward;
    fromJSON(object: any): MsgClaimDelegatorReward;
    toJSON(message: MsgClaimDelegatorReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        denomsToClaim?: {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] | undefined;
    } & {
        sender?: string | undefined;
        denomsToClaim?: ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & Record<Exclude<keyof I["denomsToClaim"][number], keyof Selection>, never>)[] & Record<Exclude<keyof I["denomsToClaim"], keyof {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimDelegatorReward>, never>>(object: I): MsgClaimDelegatorReward;
};
export declare const MsgClaimDelegatorRewardResponse: {
    encode(_: MsgClaimDelegatorRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimDelegatorRewardResponse;
    fromJSON(_: any): MsgClaimDelegatorRewardResponse;
    toJSON(_: MsgClaimDelegatorRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimDelegatorRewardResponse;
};
export declare const MsgClaimSwapReward: {
    encode(message: MsgClaimSwapReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimSwapReward;
    fromJSON(object: any): MsgClaimSwapReward;
    toJSON(message: MsgClaimSwapReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        denomsToClaim?: {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] | undefined;
    } & {
        sender?: string | undefined;
        denomsToClaim?: ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & Record<Exclude<keyof I["denomsToClaim"][number], keyof Selection>, never>)[] & Record<Exclude<keyof I["denomsToClaim"], keyof {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimSwapReward>, never>>(object: I): MsgClaimSwapReward;
};
export declare const MsgClaimSwapRewardResponse: {
    encode(_: MsgClaimSwapRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimSwapRewardResponse;
    fromJSON(_: any): MsgClaimSwapRewardResponse;
    toJSON(_: MsgClaimSwapRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimSwapRewardResponse;
};
export declare const MsgClaimSavingsReward: {
    encode(message: MsgClaimSavingsReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimSavingsReward;
    fromJSON(object: any): MsgClaimSavingsReward;
    toJSON(message: MsgClaimSavingsReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        denomsToClaim?: {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] | undefined;
    } & {
        sender?: string | undefined;
        denomsToClaim?: ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & Record<Exclude<keyof I["denomsToClaim"][number], keyof Selection>, never>)[] & Record<Exclude<keyof I["denomsToClaim"], keyof {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimSavingsReward>, never>>(object: I): MsgClaimSavingsReward;
};
export declare const MsgClaimSavingsRewardResponse: {
    encode(_: MsgClaimSavingsRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimSavingsRewardResponse;
    fromJSON(_: any): MsgClaimSavingsRewardResponse;
    toJSON(_: MsgClaimSavingsRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimSavingsRewardResponse;
};
export declare const MsgClaimEarnReward: {
    encode(message: MsgClaimEarnReward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimEarnReward;
    fromJSON(object: any): MsgClaimEarnReward;
    toJSON(message: MsgClaimEarnReward): unknown;
    fromPartial<I extends {
        sender?: string | undefined;
        denomsToClaim?: {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] | undefined;
    } & {
        sender?: string | undefined;
        denomsToClaim?: ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        } & Record<Exclude<keyof I["denomsToClaim"][number], keyof Selection>, never>)[] & Record<Exclude<keyof I["denomsToClaim"], keyof {
            denom?: string | undefined;
            multiplierName?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgClaimEarnReward>, never>>(object: I): MsgClaimEarnReward;
};
export declare const MsgClaimEarnRewardResponse: {
    encode(_: MsgClaimEarnRewardResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): MsgClaimEarnRewardResponse;
    fromJSON(_: any): MsgClaimEarnRewardResponse;
    toJSON(_: MsgClaimEarnRewardResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgClaimEarnRewardResponse;
};
/** Msg defines the incentive Msg service. */
export interface Msg {
    /** ClaimUSDXMintingReward is a message type used to claim USDX minting rewards */
    ClaimUSDXMintingReward(request: MsgClaimUSDXMintingReward): Promise<MsgClaimUSDXMintingRewardResponse>;
    /** ClaimHardReward is a message type used to claim Hard liquidity provider rewards */
    ClaimHardReward(request: MsgClaimHardReward): Promise<MsgClaimHardRewardResponse>;
    /** ClaimDelegatorReward is a message type used to claim delegator rewards */
    ClaimDelegatorReward(request: MsgClaimDelegatorReward): Promise<MsgClaimDelegatorRewardResponse>;
    /** ClaimSwapReward is a message type used to claim swap rewards */
    ClaimSwapReward(request: MsgClaimSwapReward): Promise<MsgClaimSwapRewardResponse>;
    /** ClaimSavingsReward is a message type used to claim savings rewards */
    ClaimSavingsReward(request: MsgClaimSavingsReward): Promise<MsgClaimSavingsRewardResponse>;
    /** ClaimEarnReward is a message type used to claim earn rewards */
    ClaimEarnReward(request: MsgClaimEarnReward): Promise<MsgClaimEarnRewardResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    ClaimUSDXMintingReward(request: MsgClaimUSDXMintingReward): Promise<MsgClaimUSDXMintingRewardResponse>;
    ClaimHardReward(request: MsgClaimHardReward): Promise<MsgClaimHardRewardResponse>;
    ClaimDelegatorReward(request: MsgClaimDelegatorReward): Promise<MsgClaimDelegatorRewardResponse>;
    ClaimSwapReward(request: MsgClaimSwapReward): Promise<MsgClaimSwapRewardResponse>;
    ClaimSavingsReward(request: MsgClaimSavingsReward): Promise<MsgClaimSavingsRewardResponse>;
    ClaimEarnReward(request: MsgClaimEarnReward): Promise<MsgClaimEarnRewardResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
