import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { Coin } from '../../../cosmos/base/v1beta1/coin';
export declare const protobufPackage = "kava.swap.v1beta1";
/** Params defines the parameters for the swap module. */
export interface Params {
    /** allowed_pools defines that pools that are allowed to be created */
    allowedPools: AllowedPool[];
    /** swap_fee defines the swap fee for all pools */
    swapFee: string;
}
/** AllowedPool defines a pool that is allowed to be created */
export interface AllowedPool {
    /** token_a represents the a token allowed */
    tokenA: string;
    /** token_b represents the b token allowed */
    tokenB: string;
}
/**
 * PoolRecord represents the state of a liquidity pool
 * and is used to store the state of a denominated pool
 */
export interface PoolRecord {
    /** pool_id represents the unique id of the pool */
    poolId: string;
    /** reserves_a is the a token coin reserves */
    reservesA?: Coin;
    /** reserves_b is the a token coin reserves */
    reservesB?: Coin;
    /** total_shares is the total distrubuted shares of the pool */
    totalShares: string;
}
/** ShareRecord stores the shares owned for a depositor and pool */
export interface ShareRecord {
    /** depositor represents the owner of the shares */
    depositor: Uint8Array;
    /** pool_id represents the pool the shares belong to */
    poolId: string;
    /** shares_owned represents the number of shares owned by depsoitor for the pool_id */
    sharesOwned: string;
}
export declare const Params: {
    encode(message: Params, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    fromPartial<I extends {
        allowedPools?: {
            tokenA?: string | undefined;
            tokenB?: string | undefined;
        }[] | undefined;
        swapFee?: string | undefined;
    } & {
        allowedPools?: ({
            tokenA?: string | undefined;
            tokenB?: string | undefined;
        }[] & ({
            tokenA?: string | undefined;
            tokenB?: string | undefined;
        } & {
            tokenA?: string | undefined;
            tokenB?: string | undefined;
        } & Record<Exclude<keyof I["allowedPools"][number], keyof AllowedPool>, never>)[] & Record<Exclude<keyof I["allowedPools"], keyof {
            tokenA?: string | undefined;
            tokenB?: string | undefined;
        }[]>, never>) | undefined;
        swapFee?: string | undefined;
    } & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
export declare const AllowedPool: {
    encode(message: AllowedPool, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AllowedPool;
    fromJSON(object: any): AllowedPool;
    toJSON(message: AllowedPool): unknown;
    fromPartial<I extends {
        tokenA?: string | undefined;
        tokenB?: string | undefined;
    } & {
        tokenA?: string | undefined;
        tokenB?: string | undefined;
    } & Record<Exclude<keyof I, keyof AllowedPool>, never>>(object: I): AllowedPool;
};
export declare const PoolRecord: {
    encode(message: PoolRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): PoolRecord;
    fromJSON(object: any): PoolRecord;
    toJSON(message: PoolRecord): unknown;
    fromPartial<I extends {
        poolId?: string | undefined;
        reservesA?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        reservesB?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        totalShares?: string | undefined;
    } & {
        poolId?: string | undefined;
        reservesA?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["reservesA"], keyof Coin>, never>) | undefined;
        reservesB?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["reservesB"], keyof Coin>, never>) | undefined;
        totalShares?: string | undefined;
    } & Record<Exclude<keyof I, keyof PoolRecord>, never>>(object: I): PoolRecord;
};
export declare const ShareRecord: {
    encode(message: ShareRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ShareRecord;
    fromJSON(object: any): ShareRecord;
    toJSON(message: ShareRecord): unknown;
    fromPartial<I extends {
        depositor?: Uint8Array | undefined;
        poolId?: string | undefined;
        sharesOwned?: string | undefined;
    } & {
        depositor?: Uint8Array | undefined;
        poolId?: string | undefined;
        sharesOwned?: string | undefined;
    } & Record<Exclude<keyof I, keyof ShareRecord>, never>>(object: I): ShareRecord;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
